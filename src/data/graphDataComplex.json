{
  "nodes": [
    {
      "signature": "    public void getNamespacedElementsByTag_mg74_failAssert0() throws Exception {",
      "className": "org.jsoup.nodes.ElementTest",
      "id": "root",
      "lines": [
        {
          "code": "        Assertions.assertThrows(Selector.SelectorParseException.class, () -\u003e {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            String __DSPOT_query_17 \u003d \"5P\u0026+YTN/#yO[*WW4JN-$\";",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            Document doc \u003d Jsoup.parse(\"\u003cdiv\u003e\u003cabc:def id\u003d1\u003eHello\u003c/abc:def\u003e\u003c/div\u003e\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            Elements els \u003d doc.getElementsByTag(\"abc:def\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            els.size();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            els.first().id();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            els.first().tagName();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            els.is(__DSPOT_query_17);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        });",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": true,
      "nodeLevel": 0
    },
    {
      "signature": "assertThrows",
      "className": "org.junit.jupiter.api.Assertions",
      "id": "MethodSignatureBackedByPsiMethod: \u003cT\u003eassertThrows([PsiType:Class\u003cT\u003e, PsiType:Executable])_1926352775",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 1
    },
    {
      "signature": "    public static Document parse(String html) {",
      "className": "org.jsoup.Jsoup",
      "id": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_1866495644",
      "lines": [
        {
          "code": "        return Parser.parse(html, \"\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 1
    },
    {
      "signature": "    public Elements getElementsByTag(String tagName) {",
      "className": "org.jsoup.nodes.Element",
      "id": "MethodSignatureBackedByPsiMethod: getElementsByTag([PsiType:String])_1150471544",
      "lines": [
        {
          "code": "        Validate.notEmpty(tagName);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        tagName \u003d normalize(tagName);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return Collector.collect(new Evaluator.Tag(tagName), this);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 1
    },
    {
      "signature": "size",
      "className": "java.util.ArrayList",
      "id": "MethodSignatureBackedByPsiMethod: size([])_391889604",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 1
    },
    {
      "signature": "    public String id() {",
      "className": "org.jsoup.nodes.Element",
      "id": "MethodSignatureBackedByPsiMethod: id([])_70465572",
      "lines": [
        {
          "code": "        return attributes !\u003d null ? attributes.getIgnoreCase(\"id\") :\"\";",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 1
    },
    {
      "signature": "    public @Nullable Element first() {",
      "className": "org.jsoup.select.Elements",
      "id": "MethodSignatureBackedByPsiMethod: first([])_-1145293840",
      "lines": [
        {
          "code": "        return isEmpty() ? null : get(0);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 1
    },
    {
      "signature": "    public String tagName() {",
      "className": "org.jsoup.nodes.Element",
      "id": "MethodSignatureBackedByPsiMethod: tagName([])_2016545588",
      "lines": [
        {
          "code": "        return tag.getName();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 1
    },
    {
      "signature": "    public @Nullable Element first() {",
      "className": "org.jsoup.select.Elements",
      "id": "MethodSignatureBackedByPsiMethod: first([])_-135852916",
      "lines": [
        {
          "code": "        return isEmpty() ? null : get(0);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 1
    },
    {
      "signature": "    public boolean is(String query) {",
      "className": "org.jsoup.select.Elements",
      "id": "MethodSignatureBackedByPsiMethod: is([PsiType:String])_-303853799",
      "lines": [
        {
          "code": "        Evaluator eval \u003d QueryParser.parse(query);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        for (Element e : this) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (e.is(eval))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return false;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 1
    },
    {
      "signature": "    public static Document parse(String html, String baseUri) {",
      "className": "org.jsoup.parser.Parser",
      "id": "MethodSignatureBackedByPsiMethod: parse([PsiType:String, PsiType:String])_-1056017478",
      "lines": [
        {
          "code": "        TreeBuilder treeBuilder \u003d new HtmlTreeBuilder();",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        return treeBuilder.parse(new StringReader(html), baseUri, new Parser(treeBuilder));",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 2
    },
    {
      "signature": "    public static void notEmpty(@Nullable String string) {",
      "className": "org.jsoup.helper.Validate",
      "id": "MethodSignatureBackedByPsiMethod: notEmpty([PsiType:String])_-256522515",
      "lines": [
        {
          "code": "        if (string \u003d\u003d null || string.length() \u003d\u003d 0)",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            throw new IllegalArgumentException(\"String must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 2
    },
    {
      "signature": "    public static String normalize(final String input) {",
      "className": "org.jsoup.internal.Normalizer",
      "id": "MethodSignatureBackedByPsiMethod: normalize([PsiType:String])_1481438275",
      "lines": [
        {
          "code": "        return lowerCase(input).trim();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 2
    },
    {
      "signature": "    public static Elements collect (Evaluator eval, Element root) {",
      "className": "org.jsoup.select.Collector",
      "id": "MethodSignatureBackedByPsiMethod: collect([PsiType:Evaluator, PsiType:Element])_-2138536365",
      "lines": [
        {
          "code": "        Elements elements \u003d new Elements();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        NodeTraversor.traverse(new Accumulator(root, elements, eval), root);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        return elements;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 2
    },
    {
      "signature": "        public Tag(String tagName) {",
      "className": "org.jsoup.select.Evaluator.Tag",
      "id": "MethodSignatureBackedByPsiMethod: Tag([PsiType:String])_-783416539",
      "lines": [
        {
          "code": "            this.tagName \u003d tagName;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 2
    },
    {
      "signature": "    public String getIgnoreCase(String key) {",
      "className": "org.jsoup.nodes.Attributes",
      "id": "MethodSignatureBackedByPsiMethod: getIgnoreCase([PsiType:String])_-1710959840",
      "lines": [
        {
          "code": "        int i \u003d indexOfKeyIgnoreCase(key);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        return i \u003d\u003d NotFound ? EmptyString : checkNotNull(vals[i]);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 2
    },
    {
      "signature": "isEmpty",
      "className": "java.util.ArrayList",
      "id": "MethodSignatureBackedByPsiMethod: isEmpty([])_-86325364",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 2
    },
    {
      "signature": "get",
      "className": "java.util.ArrayList",
      "id": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_1593892113",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 2
    },
    {
      "signature": "    public String getName() {",
      "className": "org.jsoup.parser.Tag",
      "id": "MethodSignatureBackedByPsiMethod: getName([])_-495737043",
      "lines": [
        {
          "code": "        return tagName;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 2
    },
    {
      "signature": "isEmpty",
      "className": "java.util.ArrayList",
      "id": "MethodSignatureBackedByPsiMethod: isEmpty([])_1447658979",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 2
    },
    {
      "signature": "get",
      "className": "java.util.ArrayList",
      "id": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_-1129142944",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 2
    },
    {
      "signature": "    public static Evaluator parse(String query) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_924335745",
      "lines": [
        {
          "code": "        try {",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            QueryParser p \u003d new QueryParser(query);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return p.parse();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        } catch (IllegalArgumentException e) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            throw new Selector.SelectorParseException(e.getMessage());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 2
    },
    {
      "signature": "    public boolean is(Evaluator evaluator) {",
      "className": "org.jsoup.nodes.Element",
      "id": "MethodSignatureBackedByPsiMethod: is([PsiType:Evaluator])_1143423091",
      "lines": [
        {
          "code": "        return evaluator.matches(this.root(), this);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 2
    },
    {
      "signature": "    Document parse(Reader input, String baseUri, Parser parser) {",
      "className": "org.jsoup.parser.TreeBuilder",
      "id": "MethodSignatureBackedByPsiMethod: parse([PsiType:Reader, PsiType:String, PsiType:Parser])_-1813351896",
      "lines": [
        {
          "code": "        initialiseParse(input, baseUri, parser);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        runParser();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        // tidy up - as the Parser and Treebuilder are retained in document for settings / fragments",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        reader.close();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        reader \u003d null;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        tokeniser \u003d null;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        stack \u003d null;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return doc;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "StringReader",
      "className": "java.io.StringReader",
      "id": "MethodSignatureBackedByPsiMethod: StringReader([PsiType:String])_-1445627906",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "    public Parser(TreeBuilder treeBuilder) {",
      "className": "org.jsoup.parser.Parser",
      "id": "MethodSignatureBackedByPsiMethod: Parser([PsiType:TreeBuilder])_1162340011",
      "lines": [
        {
          "code": "        this.treeBuilder \u003d treeBuilder;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        settings \u003d treeBuilder.defaultSettings();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        errors \u003d ParseErrorList.noTracking();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "length",
      "className": "java.lang.String",
      "id": "MethodSignatureBackedByPsiMethod: length([])_-2028283825",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "IllegalArgumentException",
      "className": "java.lang.IllegalArgumentException",
      "id": "MethodSignatureBackedByPsiMethod: IllegalArgumentException([PsiType:String])_58650947",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "trim",
      "className": "java.lang.String",
      "id": "MethodSignatureBackedByPsiMethod: trim([])_1736317472",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "    public static String lowerCase(final String input) {",
      "className": "org.jsoup.internal.Normalizer",
      "id": "MethodSignatureBackedByPsiMethod: lowerCase([PsiType:String])_-454938226",
      "lines": [
        {
          "code": "        return input !\u003d null ? input.toLowerCase(Locale.ENGLISH) : \"\";",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "    public Elements() {",
      "className": "org.jsoup.select.Elements",
      "id": "MethodSignatureBackedByPsiMethod: Elements([])_794880811",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "    public static void traverse(NodeVisitor visitor, Node root) {",
      "className": "org.jsoup.select.NodeTraversor",
      "id": "MethodSignatureBackedByPsiMethod: traverse([PsiType:NodeVisitor, PsiType:Node])_1791246505",
      "lines": [
        {
          "code": "        Node node \u003d root;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Node parent; // remember parent to find nodes that get replaced in .head",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        int depth \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        ",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        while (node !\u003d null) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            parent \u003d node.parentNode();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            visitor.head(node, depth); // visit current node",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (parent !\u003d null \u0026\u0026 !node.hasParent()) // must have been replaced; find replacement",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                node \u003d parent.childNode(node.siblingIndex()); // replace ditches parent but keeps sibling index",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (node.childNodeSize() \u003e 0) { // descend",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                node \u003d node.childNode(0);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                depth++;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                while (true) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    assert node !\u003d null; // as depth \u003e 0, will have parent",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    if (!(node.nextSibling() \u003d\u003d null \u0026\u0026 depth \u003e 0)) break;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    visitor.tail(node, depth); // when no more siblings, ascend",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    node \u003d node.parentNode();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    depth--;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                visitor.tail(node, depth);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                if (node \u003d\u003d root)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                node \u003d node.nextSibling();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "        Accumulator(Element root, Elements elements, Evaluator eval) {",
      "className": "org.jsoup.select.Collector.Accumulator",
      "id": "MethodSignatureBackedByPsiMethod: Accumulator([PsiType:Element, PsiType:Elements, PsiType:Evaluator])_-1477633170",
      "lines": [
        {
          "code": "            this.root \u003d root;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            this.elements \u003d elements;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            this.eval \u003d eval;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "    private int indexOfKeyIgnoreCase(String key) {",
      "className": "org.jsoup.nodes.Attributes",
      "id": "MethodSignatureBackedByPsiMethod: indexOfKeyIgnoreCase([PsiType:String])_-1555728248",
      "lines": [
        {
          "code": "        Validate.notNull(key);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        for (int i \u003d 0; i \u003c size; i++) {",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            if (key.equalsIgnoreCase(keys[i]))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "                return i;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return NotFound;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "    static String checkNotNull(@Nullable String val) {",
      "className": "org.jsoup.nodes.Attributes",
      "id": "MethodSignatureBackedByPsiMethod: checkNotNull([PsiType:String])_1680638990",
      "lines": [
        {
          "code": "        return val \u003d\u003d null ? EmptyString : val;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "    private QueryParser(String query) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: QueryParser([PsiType:String])_-694142982",
      "lines": [
        {
          "code": "        Validate.notEmpty(query);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        query \u003d query.trim();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        this.query \u003d query;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        this.tq \u003d new TokenQueue(query);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "    Evaluator parse() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "lines": [
        {
          "code": "        tq.consumeWhitespace();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            evals.add(new StructuralEvaluator.Root());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            combinator(tq.consume());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            findElements();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        while (!tq.isEmpty()) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            // hierarchy and extras",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            boolean seenWhite \u003d tq.consumeWhitespace();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (tq.matchesAny(combinators)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                combinator(tq.consume());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            } else if (seenWhite) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                combinator(\u0027 \u0027);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            } else { // E.class, E#id, E[attr] etc. AND",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                findElements(); // take next el, #. etc off queue",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (evals.size() \u003d\u003d 1)",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return evals.get(0);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return new CombiningEvaluator.And(evals);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "        public SelectorParseException(String msg, Object... params) {",
      "className": "org.jsoup.select.Selector.SelectorParseException",
      "id": "MethodSignatureBackedByPsiMethod: SelectorParseException([PsiType:String, PsiType:Object[]])_-275455494",
      "lines": [
        {
          "code": "            super(String.format(msg, params));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "getMessage",
      "className": "java.lang.Throwable",
      "id": "MethodSignatureBackedByPsiMethod: getMessage([])_1866399095",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "matches",
      "className": "org.jsoup.select.Evaluator",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:Element, PsiType:Element])_327867200",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "    public Element root() {",
      "className": "org.jsoup.nodes.Element",
      "id": "MethodSignatureBackedByPsiMethod: root([])_-1608198050",
      "lines": [
        {
          "code": "        return (Element) super.root(); // probably a document, but always at least an element",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 3
    },
    {
      "signature": "    protected void initialiseParse(Reader input, String baseUri, Parser parser) {",
      "className": "org.jsoup.parser.TreeBuilder",
      "id": "MethodSignatureBackedByPsiMethod: initialiseParse([PsiType:Reader, PsiType:String, PsiType:Parser])_1195116331",
      "lines": [
        {
          "code": "        Validate.notNull(input, \"String input must not be null\");",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        Validate.notNull(baseUri, \"BaseURI must not be null\");",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        Validate.notNull(parser);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        doc \u003d new Document(baseUri);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        doc.parser(parser);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        this.parser \u003d parser;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        settings \u003d parser.settings();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        reader \u003d new CharacterReader(input);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        currentToken \u003d null;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        tokeniser \u003d new Tokeniser(reader, parser.getErrors());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        stack \u003d new ArrayList\u003c\u003e(32);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        this.baseUri \u003d baseUri;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    protected void runParser() {",
      "className": "org.jsoup.parser.TreeBuilder",
      "id": "MethodSignatureBackedByPsiMethod: runParser([])_-1640989844",
      "lines": [
        {
          "code": "        final Tokeniser tokeniser \u003d this.tokeniser;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        final Token.TokenType eof \u003d Token.TokenType.EOF;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        while (true) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            Token token \u003d tokeniser.read();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            process(token);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            token.reset();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (token.type \u003d\u003d eof)",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public void close() {",
      "className": "org.jsoup.parser.CharacterReader",
      "id": "MethodSignatureBackedByPsiMethod: close([])_-1719120519",
      "lines": [
        {
          "code": "        if (reader \u003d\u003d null)",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            return;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        try {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            reader.close();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        } catch (IOException ignored) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } finally {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            reader \u003d null;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            charBuf \u003d null;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            stringCache \u003d null;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "defaultSettings",
      "className": "org.jsoup.parser.TreeBuilder",
      "id": "MethodSignatureBackedByPsiMethod: defaultSettings([])_-812996206",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public static ParseErrorList noTracking() {",
      "className": "org.jsoup.parser.ParseErrorList",
      "id": "MethodSignatureBackedByPsiMethod: noTracking([])_-2073258899",
      "lines": [
        {
          "code": "        return new ParseErrorList(0, 0);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "toLowerCase",
      "className": "java.lang.String",
      "id": "MethodSignatureBackedByPsiMethod: toLowerCase([PsiType:Locale])_1694331601",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public @Nullable final Node parentNode() {",
      "className": "org.jsoup.nodes.Node",
      "id": "MethodSignatureBackedByPsiMethod: parentNode([])_57730898",
      "lines": [
        {
          "code": "        return parentNode;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "head",
      "className": "org.jsoup.select.NodeVisitor",
      "id": "MethodSignatureBackedByPsiMethod: head([PsiType:Node, PsiType:int])_113617089",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public boolean hasParent() {",
      "className": "org.jsoup.nodes.Node",
      "id": "MethodSignatureBackedByPsiMethod: hasParent([])_-183285891",
      "lines": [
        {
          "code": "        return parentNode !\u003d null;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public Node childNode(int index) {",
      "className": "org.jsoup.nodes.Node",
      "id": "MethodSignatureBackedByPsiMethod: childNode([PsiType:int])_2098516477",
      "lines": [
        {
          "code": "        return ensureChildNodes().get(index);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public int siblingIndex() {",
      "className": "org.jsoup.nodes.Node",
      "id": "MethodSignatureBackedByPsiMethod: siblingIndex([])_-1059228107",
      "lines": [
        {
          "code": "        return siblingIndex;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "childNodeSize",
      "className": "org.jsoup.nodes.Node",
      "id": "MethodSignatureBackedByPsiMethod: childNodeSize([])_-1244893490",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public Node childNode(int index) {",
      "className": "org.jsoup.nodes.Node",
      "id": "MethodSignatureBackedByPsiMethod: childNode([PsiType:int])_11792431",
      "lines": [
        {
          "code": "        return ensureChildNodes().get(index);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public @Nullable Node nextSibling() {",
      "className": "org.jsoup.nodes.Node",
      "id": "MethodSignatureBackedByPsiMethod: nextSibling([])_-70803830",
      "lines": [
        {
          "code": "        if (parentNode \u003d\u003d null)",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            return null; // root",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        final List\u003cNode\u003e siblings \u003d parentNode.ensureChildNodes();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        final int index \u003d siblingIndex+1;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        if (siblings.size() \u003e index)",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            return siblings.get(index);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return null;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "tail",
      "className": "org.jsoup.select.NodeVisitor",
      "id": "MethodSignatureBackedByPsiMethod: tail([PsiType:Node, PsiType:int])_1122625413",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public @Nullable final Node parentNode() {",
      "className": "org.jsoup.nodes.Node",
      "id": "MethodSignatureBackedByPsiMethod: parentNode([])_1009898624",
      "lines": [
        {
          "code": "        return parentNode;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "tail",
      "className": "org.jsoup.select.NodeVisitor",
      "id": "MethodSignatureBackedByPsiMethod: tail([PsiType:Node, PsiType:int])_678582090",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public @Nullable Node nextSibling() {",
      "className": "org.jsoup.nodes.Node",
      "id": "MethodSignatureBackedByPsiMethod: nextSibling([])_-407626644",
      "lines": [
        {
          "code": "        if (parentNode \u003d\u003d null)",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            return null; // root",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        final List\u003cNode\u003e siblings \u003d parentNode.ensureChildNodes();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        final int index \u003d siblingIndex+1;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        if (siblings.size() \u003e index)",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            return siblings.get(index);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return null;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public static void notNull(@Nullable Object obj) {",
      "className": "org.jsoup.helper.Validate",
      "id": "MethodSignatureBackedByPsiMethod: notNull([PsiType:Object])_1046537256",
      "lines": [
        {
          "code": "        if (obj \u003d\u003d null)",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            throw new IllegalArgumentException(\"Object must not be null\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "equalsIgnoreCase",
      "className": "java.lang.String",
      "id": "MethodSignatureBackedByPsiMethod: equalsIgnoreCase([PsiType:String])_421446078",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public static void notEmpty(@Nullable String string) {",
      "className": "org.jsoup.helper.Validate",
      "id": "MethodSignatureBackedByPsiMethod: notEmpty([PsiType:String])_8925104",
      "lines": [
        {
          "code": "        if (string \u003d\u003d null || string.length() \u003d\u003d 0)",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            throw new IllegalArgumentException(\"String must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "trim",
      "className": "java.lang.String",
      "id": "MethodSignatureBackedByPsiMethod: trim([])_-338439612",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public TokenQueue(String data) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: TokenQueue([PsiType:String])_1443307589",
      "lines": [
        {
          "code": "        Validate.notNull(data);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        queue \u003d data;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public boolean consumeWhitespace() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: consumeWhitespace([])_-1749206023",
      "lines": [
        {
          "code": "        boolean seen \u003d false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        while (matchesWhitespace()) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos++;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            seen \u003d true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return seen;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public boolean matchesAny(String... seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchesAny([PsiType:String[]])_-1278839358",
      "lines": [
        {
          "code": "        for (String s : seq) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (matches(s))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return false;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_963968758",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    private void combinator(char combinator) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "lines": [
        {
          "code": "        tq.consumeWhitespace();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String subQuery \u003d consumeSubQuery(); // support multi \u003e childs",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Evaluator rootEval; // the new topmost evaluator",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Evaluator currentEval; // the evaluator the new eval will be combined to. could be root, or rightmost or.",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Evaluator newEval \u003d parse(subQuery); // the evaluator to add into target evaluator",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        boolean replaceRightMost \u003d false;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (evals.size() \u003d\u003d 1) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            rootEval \u003d currentEval \u003d evals.get(0);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            // make sure OR (,) has precedence:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (rootEval instanceof CombiningEvaluator.Or \u0026\u0026 combinator !\u003d \u0027,\u0027) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d ((CombiningEvaluator.Or) currentEval).rightMostEvaluator();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                assert currentEval !\u003d null; // rightMost signature can return null (if none set), but always will have one by this point",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                replaceRightMost \u003d true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            rootEval \u003d currentEval \u003d new CombiningEvaluator.And(evals);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.clear();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        // for most combinators: change the current eval into an AND of the current eval and the new eval",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        switch (combinator) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027\u003e\u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.ImmediateParent(currentEval), newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027 \u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.Parent(currentEval), newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027+\u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.ImmediatePreviousSibling(currentEval), newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027~\u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.PreviousSibling(currentEval), newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027,\u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                CombiningEvaluator.Or or;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                if (currentEval instanceof CombiningEvaluator.Or) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    or \u003d (CombiningEvaluator.Or) currentEval;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    or \u003d new CombiningEvaluator.Or();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    or.add(currentEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                or.add(newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d or;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            default:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (replaceRightMost)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            ((CombiningEvaluator.Or) rootEval).replaceRightMostEvaluator(currentEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else rootEval \u003d currentEval;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.add(rootEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public char consume() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: consume([])_1688299496",
      "lines": [
        {
          "code": "        return queue.charAt(pos++);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    private void findElements() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "lines": [
        {
          "code": "        if (tq.matchChomp(\"#\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            byId();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\".\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            byClass();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchesWord() || tq.matches(\"*|\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            byTag();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\"[\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            byAttribute();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\"*\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            allElements();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":lt(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            indexLessThan();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":gt(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            indexGreaterThan();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":eq(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            indexEquals();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\":has(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            has();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\":contains(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            contains(false);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\":containsOwn(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            contains(true);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\":containsData(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            containsData();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\":matches(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            matches(false);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\":matchesOwn(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            matches(true);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\":not(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            not();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\telse if (tq.matchChomp(\":nth-child(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        \tcssNthChild(false, false);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":nth-last-child(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        \tcssNthChild(true, false);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":nth-of-type(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        \tcssNthChild(false, true);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":nth-last-of-type(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        \tcssNthChild(true, true);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":first-child\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        \tevals.add(new Evaluator.IsFirstChild());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":last-child\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        \tevals.add(new Evaluator.IsLastChild());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":first-of-type\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        },
        {
          "code": "        \tevals.add(new Evaluator.IsFirstOfType());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":last-of-type\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        },
        {
          "code": "        \tevals.add(new Evaluator.IsLastOfType());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":only-child\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        },
        {
          "code": "        \tevals.add(new Evaluator.IsOnlyChild());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":only-of-type\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        },
        {
          "code": "        \tevals.add(new Evaluator.IsOnlyOfType());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":empty\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        },
        {
          "code": "        \tevals.add(new Evaluator.IsEmpty());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":root\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        },
        {
          "code": "        \tevals.add(new Evaluator.IsRoot());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":matchText\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        },
        {
          "code": "            evals.add(new Evaluator.MatchText());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\telse // unhandled",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            throw new Selector.SelectorParseException(\"Could not parse query \u0027%s\u0027: unexpected token at \u0027%s\u0027\", query, tq.remainder());",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        }
      ],
      "addCovered": true,
      "nodeLevel": 4
    },
    {
      "signature": "    public boolean isEmpty() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: isEmpty([])_501044344",
      "lines": [
        {
          "code": "        return remainingLength() \u003d\u003d 0;",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public boolean consumeWhitespace() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: consumeWhitespace([])_1759284288",
      "lines": [
        {
          "code": "        boolean seen \u003d false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        while (matchesWhitespace()) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos++;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            seen \u003d true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return seen;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public boolean matchesAny(String... seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchesAny([PsiType:String[]])_1750364795",
      "lines": [
        {
          "code": "        for (String s : seq) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (matches(s))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return false;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    private void combinator(char combinator) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "lines": [
        {
          "code": "        tq.consumeWhitespace();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String subQuery \u003d consumeSubQuery(); // support multi \u003e childs",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Evaluator rootEval; // the new topmost evaluator",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Evaluator currentEval; // the evaluator the new eval will be combined to. could be root, or rightmost or.",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Evaluator newEval \u003d parse(subQuery); // the evaluator to add into target evaluator",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        boolean replaceRightMost \u003d false;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (evals.size() \u003d\u003d 1) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            rootEval \u003d currentEval \u003d evals.get(0);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            // make sure OR (,) has precedence:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (rootEval instanceof CombiningEvaluator.Or \u0026\u0026 combinator !\u003d \u0027,\u0027) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d ((CombiningEvaluator.Or) currentEval).rightMostEvaluator();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                assert currentEval !\u003d null; // rightMost signature can return null (if none set), but always will have one by this point",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                replaceRightMost \u003d true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            rootEval \u003d currentEval \u003d new CombiningEvaluator.And(evals);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.clear();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        // for most combinators: change the current eval into an AND of the current eval and the new eval",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        switch (combinator) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027\u003e\u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.ImmediateParent(currentEval), newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027 \u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.Parent(currentEval), newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027+\u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.ImmediatePreviousSibling(currentEval), newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027~\u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.PreviousSibling(currentEval), newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027,\u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                CombiningEvaluator.Or or;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                if (currentEval instanceof CombiningEvaluator.Or) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    or \u003d (CombiningEvaluator.Or) currentEval;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    or \u003d new CombiningEvaluator.Or();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    or.add(currentEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                or.add(newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d or;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            default:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (replaceRightMost)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            ((CombiningEvaluator.Or) rootEval).replaceRightMostEvaluator(currentEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else rootEval \u003d currentEval;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.add(rootEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public char consume() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: consume([])_-35845139",
      "lines": [
        {
          "code": "        return queue.charAt(pos++);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    private void combinator(char combinator) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "lines": [
        {
          "code": "        tq.consumeWhitespace();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String subQuery \u003d consumeSubQuery(); // support multi \u003e childs",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Evaluator rootEval; // the new topmost evaluator",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Evaluator currentEval; // the evaluator the new eval will be combined to. could be root, or rightmost or.",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Evaluator newEval \u003d parse(subQuery); // the evaluator to add into target evaluator",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        boolean replaceRightMost \u003d false;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (evals.size() \u003d\u003d 1) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            rootEval \u003d currentEval \u003d evals.get(0);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            // make sure OR (,) has precedence:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (rootEval instanceof CombiningEvaluator.Or \u0026\u0026 combinator !\u003d \u0027,\u0027) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d ((CombiningEvaluator.Or) currentEval).rightMostEvaluator();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                assert currentEval !\u003d null; // rightMost signature can return null (if none set), but always will have one by this point",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                replaceRightMost \u003d true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            rootEval \u003d currentEval \u003d new CombiningEvaluator.And(evals);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.clear();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        // for most combinators: change the current eval into an AND of the current eval and the new eval",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        switch (combinator) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027\u003e\u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.ImmediateParent(currentEval), newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027 \u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.Parent(currentEval), newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027+\u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.ImmediatePreviousSibling(currentEval), newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027~\u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.PreviousSibling(currentEval), newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            case \u0027,\u0027:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                CombiningEvaluator.Or or;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                if (currentEval instanceof CombiningEvaluator.Or) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    or \u003d (CombiningEvaluator.Or) currentEval;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    or \u003d new CombiningEvaluator.Or();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                    or.add(currentEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                or.add(newEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                currentEval \u003d or;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            default:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (replaceRightMost)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            ((CombiningEvaluator.Or) rootEval).replaceRightMostEvaluator(currentEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else rootEval \u003d currentEval;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.add(rootEval);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    private void findElements() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "lines": [
        {
          "code": "        if (tq.matchChomp(\"#\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            byId();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\".\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            byClass();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchesWord() || tq.matches(\"*|\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            byTag();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\"[\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            byAttribute();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\"*\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            allElements();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":lt(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            indexLessThan();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":gt(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            indexGreaterThan();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":eq(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            indexEquals();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\":has(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            has();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\":contains(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            contains(false);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\":containsOwn(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            contains(true);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\":containsData(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            containsData();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\":matches(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            matches(false);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\":matchesOwn(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            matches(true);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matches(\":not(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            not();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\telse if (tq.matchChomp(\":nth-child(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        \tcssNthChild(false, false);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":nth-last-child(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        \tcssNthChild(true, false);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":nth-of-type(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        \tcssNthChild(false, true);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":nth-last-of-type(\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        \tcssNthChild(true, true);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":first-child\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        \tevals.add(new Evaluator.IsFirstChild());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":last-child\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        \tevals.add(new Evaluator.IsLastChild());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":first-of-type\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        },
        {
          "code": "        \tevals.add(new Evaluator.IsFirstOfType());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":last-of-type\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        },
        {
          "code": "        \tevals.add(new Evaluator.IsLastOfType());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":only-child\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        },
        {
          "code": "        \tevals.add(new Evaluator.IsOnlyChild());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":only-of-type\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        },
        {
          "code": "        \tevals.add(new Evaluator.IsOnlyOfType());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":empty\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        },
        {
          "code": "        \tevals.add(new Evaluator.IsEmpty());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":root\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        },
        {
          "code": "        \tevals.add(new Evaluator.IsRoot());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else if (tq.matchChomp(\":matchText\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        },
        {
          "code": "            evals.add(new Evaluator.MatchText());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\telse // unhandled",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            throw new Selector.SelectorParseException(\"Could not parse query \u0027%s\u0027: unexpected token at \u0027%s\u0027\", query, tq.remainder());",
          "callsMethod": true,
          "covered": true,
          "addCovered": true
        }
      ],
      "addCovered": true,
      "nodeLevel": 4
    },
    {
      "signature": "size",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: size([])_-886360486",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "get",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_1584834289",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "        And(Collection\u003cEvaluator\u003e evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Collection\u003cEvaluator\u003e])_-1830821654",
      "lines": [
        {
          "code": "            super(evaluators);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "IllegalStateException",
      "className": "java.lang.IllegalStateException",
      "id": "MethodSignatureBackedByPsiMethod: IllegalStateException([PsiType:String])_670869707",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "format",
      "className": "java.lang.String",
      "id": "MethodSignatureBackedByPsiMethod: format([PsiType:String, PsiType:Object[]])_147965286",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public Node root() {",
      "className": "org.jsoup.nodes.Node",
      "id": "MethodSignatureBackedByPsiMethod: root([])_-13569482",
      "lines": [
        {
          "code": "        Node node \u003d this;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        while (node.parentNode !\u003d null)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            node \u003d node.parentNode;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return node;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 4
    },
    {
      "signature": "    public static void notNull(@Nullable Object obj, String msg) {",
      "className": "org.jsoup.helper.Validate",
      "id": "MethodSignatureBackedByPsiMethod: notNull([PsiType:Object, PsiType:String])_1404977726",
      "lines": [
        {
          "code": "        if (obj \u003d\u003d null)",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            throw new IllegalArgumentException(msg);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public static void notNull(@Nullable Object obj, String msg) {",
      "className": "org.jsoup.helper.Validate",
      "id": "MethodSignatureBackedByPsiMethod: notNull([PsiType:Object, PsiType:String])_-2119631475",
      "lines": [
        {
          "code": "        if (obj \u003d\u003d null)",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            throw new IllegalArgumentException(msg);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public static void notNull(@Nullable Object obj) {",
      "className": "org.jsoup.helper.Validate",
      "id": "MethodSignatureBackedByPsiMethod: notNull([PsiType:Object])_1850795666",
      "lines": [
        {
          "code": "        if (obj \u003d\u003d null)",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            throw new IllegalArgumentException(\"Object must not be null\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public Document(String baseUri) {",
      "className": "org.jsoup.nodes.Document",
      "id": "MethodSignatureBackedByPsiMethod: Document([PsiType:String])_1173232975",
      "lines": [
        {
          "code": "        super(Tag.valueOf(\"#root\", ParseSettings.htmlDefault), baseUri);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        this.location \u003d baseUri;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        this.parser \u003d Parser.htmlParser(); // default, but overridable",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public Document parser(Parser parser) {",
      "className": "org.jsoup.nodes.Document",
      "id": "MethodSignatureBackedByPsiMethod: parser([PsiType:Parser])_-1334598918",
      "lines": [
        {
          "code": "        this.parser \u003d parser;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        return this;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public ParseSettings settings() {",
      "className": "org.jsoup.parser.Parser",
      "id": "MethodSignatureBackedByPsiMethod: settings([])_-160012383",
      "lines": [
        {
          "code": "        return settings;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public CharacterReader(Reader input) {",
      "className": "org.jsoup.parser.CharacterReader",
      "id": "MethodSignatureBackedByPsiMethod: CharacterReader([PsiType:Reader])_-849971096",
      "lines": [
        {
          "code": "        this(input, maxBufferLen);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    Tokeniser(CharacterReader reader, ParseErrorList errors) {",
      "className": "org.jsoup.parser.Tokeniser",
      "id": "MethodSignatureBackedByPsiMethod: Tokeniser([PsiType:CharacterReader, PsiType:ParseErrorList])_-562299956",
      "lines": [
        {
          "code": "        this.reader \u003d reader;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        this.errors \u003d errors;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public ParseErrorList getErrors() {",
      "className": "org.jsoup.parser.Parser",
      "id": "MethodSignatureBackedByPsiMethod: getErrors([])_1543974038",
      "lines": [
        {
          "code": "        return errors;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "ArrayList",
      "className": "java.util.ArrayList",
      "id": "MethodSignatureBackedByPsiMethod: ArrayList([PsiType:int])_-1016350441",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    Token read() {",
      "className": "org.jsoup.parser.Tokeniser",
      "id": "MethodSignatureBackedByPsiMethod: read([])_1018338730",
      "lines": [
        {
          "code": "        while (!isEmitPending) {",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            state.read(this, reader);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        final StringBuilder cb \u003d this.charsBuilder;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        if (cb.length() !\u003d 0) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            String str \u003d cb.toString();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            cb.delete(0, cb.length());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            charsString \u003d null;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return charPending.data(str);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else if (charsString !\u003d null) {",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            Token token \u003d charPending.data(charsString);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            charsString \u003d null;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            return token;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            isEmitPending \u003d false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            return emitPending;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "process",
      "className": "org.jsoup.parser.TreeBuilder",
      "id": "MethodSignatureBackedByPsiMethod: process([PsiType:Token])_1455342470",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "reset",
      "className": "org.jsoup.parser.Token",
      "id": "MethodSignatureBackedByPsiMethod: reset([])_1175472875",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "close",
      "className": "java.io.Reader",
      "id": "MethodSignatureBackedByPsiMethod: close([])_-292742612",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    ParseErrorList(int initialCapacity, int maxSize) {",
      "className": "org.jsoup.parser.ParseErrorList",
      "id": "MethodSignatureBackedByPsiMethod: ParseErrorList([PsiType:int, PsiType:int])_-1349476676",
      "lines": [
        {
          "code": "        super(initialCapacity);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        this.initialCapacity \u003d initialCapacity;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        this.maxSize \u003d maxSize;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "get",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_479779899",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "ensureChildNodes",
      "className": "org.jsoup.nodes.Node",
      "id": "MethodSignatureBackedByPsiMethod: ensureChildNodes([])_-1353120194",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "get",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_1619784959",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "ensureChildNodes",
      "className": "org.jsoup.nodes.Node",
      "id": "MethodSignatureBackedByPsiMethod: ensureChildNodes([])_1427242307",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "ensureChildNodes",
      "className": "org.jsoup.nodes.Node",
      "id": "MethodSignatureBackedByPsiMethod: ensureChildNodes([])_-641231780",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "size",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: size([])_482179452",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "get",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_282945674",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "ensureChildNodes",
      "className": "org.jsoup.nodes.Node",
      "id": "MethodSignatureBackedByPsiMethod: ensureChildNodes([])_437558792",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "size",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: size([])_353750821",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "get",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_1419110599",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "IllegalArgumentException",
      "className": "java.lang.IllegalArgumentException",
      "id": "MethodSignatureBackedByPsiMethod: IllegalArgumentException([PsiType:String])_1976596175",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "length",
      "className": "java.lang.String",
      "id": "MethodSignatureBackedByPsiMethod: length([])_1518882",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "IllegalArgumentException",
      "className": "java.lang.IllegalArgumentException",
      "id": "MethodSignatureBackedByPsiMethod: IllegalArgumentException([PsiType:String])_-322764818",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public static void notNull(@Nullable Object obj) {",
      "className": "org.jsoup.helper.Validate",
      "id": "MethodSignatureBackedByPsiMethod: notNull([PsiType:Object])_-875742159",
      "lines": [
        {
          "code": "        if (obj \u003d\u003d null)",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            throw new IllegalArgumentException(\"Object must not be null\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchesWhitespace() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchesWhitespace([])_1310483025",
      "lines": [
        {
          "code": "        return !isEmpty() \u0026\u0026 StringUtil.isWhitespace(queue.charAt(pos));",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1782767532",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean consumeWhitespace() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: consumeWhitespace([])_-317847871",
      "lines": [
        {
          "code": "        boolean seen \u003d false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        while (matchesWhitespace()) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos++;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            seen \u003d true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return seen;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private String consumeSubQuery() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: consumeSubQuery([])_1906172614",
      "lines": [
        {
          "code": "        StringBuilder sq \u003d StringUtil.borrowBuilder();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        while (!tq.isEmpty()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (tq.matches(\"(\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                sq.append(\"(\").append(tq.chompBalanced(\u0027(\u0027, \u0027)\u0027)).append(\")\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (tq.matches(\"[\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                sq.append(\"[\").append(tq.chompBalanced(\u0027[\u0027, \u0027]\u0027)).append(\"]\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (tq.matchesAny(combinators))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                sq.append(tq.consume());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return StringUtil.releaseBuilder(sq);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public static Evaluator parse(String query) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_-739053883",
      "lines": [
        {
          "code": "        try {",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            QueryParser p \u003d new QueryParser(query);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return p.parse();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        } catch (IllegalArgumentException e) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            throw new Selector.SelectorParseException(e.getMessage());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "size",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: size([])_-643433549",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "get",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_-1934048725",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    @Nullable Evaluator rightMostEvaluator() {",
      "className": "org.jsoup.select.CombiningEvaluator",
      "id": "MethodSignatureBackedByPsiMethod: rightMostEvaluator([])_806052303",
      "lines": [
        {
          "code": "        return num \u003e 0 ? evaluators.get(num - 1) : null;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Collection\u003cEvaluator\u003e evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Collection\u003cEvaluator\u003e])_-1305904887",
      "lines": [
        {
          "code": "            super(evaluators);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "clear",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: clear([])_895597708",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Evaluator... evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_-514692521",
      "lines": [
        {
          "code": "            this(Arrays.asList(evaluators));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public ImmediateParent(Evaluator evaluator) {",
      "className": "org.jsoup.select.StructuralEvaluator.ImmediateParent",
      "id": "MethodSignatureBackedByPsiMethod: ImmediateParent([PsiType:Evaluator])_-875621291",
      "lines": [
        {
          "code": "            this.evaluator \u003d evaluator;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Evaluator... evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_365369941",
      "lines": [
        {
          "code": "            this(Arrays.asList(evaluators));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public Parent(Evaluator evaluator) {",
      "className": "org.jsoup.select.StructuralEvaluator.Parent",
      "id": "MethodSignatureBackedByPsiMethod: Parent([PsiType:Evaluator])_914787972",
      "lines": [
        {
          "code": "            this.evaluator \u003d evaluator;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Evaluator... evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_593758552",
      "lines": [
        {
          "code": "            this(Arrays.asList(evaluators));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public ImmediatePreviousSibling(Evaluator evaluator) {",
      "className": "org.jsoup.select.StructuralEvaluator.ImmediatePreviousSibling",
      "id": "MethodSignatureBackedByPsiMethod: ImmediatePreviousSibling([PsiType:Evaluator])_-455942428",
      "lines": [
        {
          "code": "            this.evaluator \u003d evaluator;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Evaluator... evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_-797619536",
      "lines": [
        {
          "code": "            this(Arrays.asList(evaluators));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public PreviousSibling(Evaluator evaluator) {",
      "className": "org.jsoup.select.StructuralEvaluator.PreviousSibling",
      "id": "MethodSignatureBackedByPsiMethod: PreviousSibling([PsiType:Evaluator])_-980799745",
      "lines": [
        {
          "code": "            this.evaluator \u003d evaluator;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        Or() {",
      "className": "org.jsoup.select.CombiningEvaluator.Or",
      "id": "MethodSignatureBackedByPsiMethod: Or([])_-1334074171",
      "lines": [
        {
          "code": "            super();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public void add(Evaluator e) {",
      "className": "org.jsoup.select.CombiningEvaluator.Or",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:Evaluator])_-2000888944",
      "lines": [
        {
          "code": "            evaluators.add(e);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            updateNumEvaluators();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public void add(Evaluator e) {",
      "className": "org.jsoup.select.CombiningEvaluator.Or",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:Evaluator])_1177794212",
      "lines": [
        {
          "code": "            evaluators.add(e);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            updateNumEvaluators();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public SelectorParseException(String msg, Object... params) {",
      "className": "org.jsoup.select.Selector.SelectorParseException",
      "id": "MethodSignatureBackedByPsiMethod: SelectorParseException([PsiType:String, PsiType:Object[]])_121873093",
      "lines": [
        {
          "code": "            super(String.format(msg, params));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    void replaceRightMostEvaluator(Evaluator replacement) {",
      "className": "org.jsoup.select.CombiningEvaluator",
      "id": "MethodSignatureBackedByPsiMethod: replaceRightMostEvaluator([PsiType:Evaluator])_1137175690",
      "lines": [
        {
          "code": "        evaluators.set(num - 1, replacement);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_800801340",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "charAt",
      "className": "java.lang.String",
      "id": "MethodSignatureBackedByPsiMethod: charAt([PsiType:int])_1502034996",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-316661277",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void byId() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: byId([])_381649661",
      "lines": [
        {
          "code": "        String id \u003d tq.consumeCssIdentifier();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(id);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.add(new Evaluator.Id(id));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1192226535",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void byClass() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: byClass([])_1885815566",
      "lines": [
        {
          "code": "        String className \u003d tq.consumeCssIdentifier();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(className);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.add(new Evaluator.Class(className.trim()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchesWord() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchesWord([])_-211788337",
      "lines": [
        {
          "code": "        return !isEmpty() \u0026\u0026 Character.isLetterOrDigit(queue.charAt(pos));",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-814992849",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void byTag() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: byTag([])_1943026029",
      "lines": [
        {
          "code": "        // todo - these aren\u0027t dealing perfectly with case sensitivity. For case sensitive parsers, we should also make",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        // the tag in the selector case-sensitive (and also attribute names). But for now, normalize (lower-case) for",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        // consistency - both the selector and the element tag",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String tagName \u003d normalize(tq.consumeElementSelector());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(tagName);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        // namespaces: wildcard match equals(tagName) or ending in \":\"+tagName",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (tagName.startsWith(\"*|\")) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new CombiningEvaluator.Or(new Evaluator.Tag(tagName), new Evaluator.TagEndsWith(tagName.replace(\"*|\", \":\"))));",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (tagName.contains(\"|\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "                tagName \u003d tagName.replace(\"|\", \":\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.Tag(tagName));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_816571388",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void byAttribute() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: byAttribute([])_1247905230",
      "lines": [
        {
          "code": "        TokenQueue cq \u003d new TokenQueue(tq.chompBalanced(\u0027[\u0027, \u0027]\u0027)); // content queue",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String key \u003d cq.consumeToAny(AttributeEvals); // eq, not, start, end, contain, match, (no val)",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(key);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        cq.consumeWhitespace();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (cq.isEmpty()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (key.startsWith(\"^\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.AttributeStarting(key.substring(1)));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.Attribute(key));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (cq.matchChomp(\"\u003d\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.AttributeWithValue(key, cq.remainder()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (cq.matchChomp(\"!\u003d\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.AttributeWithValueNot(key, cq.remainder()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (cq.matchChomp(\"^\u003d\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (cq.matchChomp(\"$\u003d\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (cq.matchChomp(\"*\u003d\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (cq.matchChomp(\"~\u003d\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                throw new Selector.SelectorParseException(\"Could not parse attribute query \u0027%s\u0027: unexpected token at \u0027%s\u0027\", query, cq.remainder());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_1923326596",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void allElements() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: allElements([])_-557689707",
      "lines": [
        {
          "code": "        evals.add(new Evaluator.AllElements());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1745710176",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void indexLessThan() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: indexLessThan([])_-364401254",
      "lines": [
        {
          "code": "        evals.add(new Evaluator.IndexLessThan(consumeIndex()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1292081530",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void indexGreaterThan() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: indexGreaterThan([])_763700557",
      "lines": [
        {
          "code": "        evals.add(new Evaluator.IndexGreaterThan(consumeIndex()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_1880507488",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void indexEquals() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: indexEquals([])_-40535490",
      "lines": [
        {
          "code": "        evals.add(new Evaluator.IndexEquals(consumeIndex()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1293455371",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void has() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: has([])_329673005",
      "lines": [
        {
          "code": "        tq.consume(\":has\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String subQuery \u003d tq.chompBalanced(\u0027(\u0027, \u0027)\u0027);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.add(new StructuralEvaluator.Has(parse(subQuery)));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-508349538",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void contains(boolean own) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: contains([PsiType:boolean])_-241747643",
      "lines": [
        {
          "code": "        tq.consume(own ? \":containsOwn\" : \":contains\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String searchText \u003d TokenQueue.unescape(tq.chompBalanced(\u0027(\u0027, \u0027)\u0027));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (own)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.ContainsOwnText(searchText));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.ContainsText(searchText));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-968670686",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void contains(boolean own) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: contains([PsiType:boolean])_-1395212682",
      "lines": [
        {
          "code": "        tq.consume(own ? \":containsOwn\" : \":contains\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String searchText \u003d TokenQueue.unescape(tq.chompBalanced(\u0027(\u0027, \u0027)\u0027));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (own)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.ContainsOwnText(searchText));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.ContainsText(searchText));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1996630484",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void containsData() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: containsData([])_21349907",
      "lines": [
        {
          "code": "        tq.consume(\":containsData\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String searchText \u003d TokenQueue.unescape(tq.chompBalanced(\u0027(\u0027, \u0027)\u0027));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(searchText, \":containsData(text) query must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.add(new Evaluator.ContainsData(searchText));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1623231108",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void matches(boolean own) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:boolean])_-1502633458",
      "lines": [
        {
          "code": "        tq.consume(own ? \":matchesOwn\" : \":matches\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String regex \u003d tq.chompBalanced(\u0027(\u0027, \u0027)\u0027); // don\u0027t unescape, as regex bits will be escaped",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (own)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.MatchesOwn(Pattern.compile(regex)));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.Matches(Pattern.compile(regex)));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_699897855",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void matches(boolean own) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:boolean])_-1968709231",
      "lines": [
        {
          "code": "        tq.consume(own ? \":matchesOwn\" : \":matches\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String regex \u003d tq.chompBalanced(\u0027(\u0027, \u0027)\u0027); // don\u0027t unescape, as regex bits will be escaped",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (own)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.MatchesOwn(Pattern.compile(regex)));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.Matches(Pattern.compile(regex)));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_549216363",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void not() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: not([])_1061997001",
      "lines": [
        {
          "code": "        tq.consume(\":not\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String subQuery \u003d tq.chompBalanced(\u0027(\u0027, \u0027)\u0027);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.add(new StructuralEvaluator.Not(parse(subQuery)));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_344154913",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "\tprivate void cssNthChild(boolean backwards, boolean ofType) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_637460496",
      "lines": [
        {
          "code": "\t\tString argS \u003d normalize(tq.chompTo(\")\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mAB \u003d NTH_AB.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mB \u003d NTH_B.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tfinal int a, b;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (\"odd\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 1;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (\"even\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mAB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d mAB.group(3) !\u003d null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d mAB.group(4) !\u003d null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index \u0027%s\u0027: unexpected format\", argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (ofType)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\telse {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_1723595100",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "\tprivate void cssNthChild(boolean backwards, boolean ofType) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_225074921",
      "lines": [
        {
          "code": "\t\tString argS \u003d normalize(tq.chompTo(\")\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mAB \u003d NTH_AB.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mB \u003d NTH_B.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tfinal int a, b;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (\"odd\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 1;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (\"even\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mAB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d mAB.group(3) !\u003d null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d mAB.group(4) !\u003d null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index \u0027%s\u0027: unexpected format\", argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (ofType)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\telse {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-578346516",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "\tprivate void cssNthChild(boolean backwards, boolean ofType) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_-1552559770",
      "lines": [
        {
          "code": "\t\tString argS \u003d normalize(tq.chompTo(\")\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mAB \u003d NTH_AB.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mB \u003d NTH_B.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tfinal int a, b;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (\"odd\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 1;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (\"even\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mAB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d mAB.group(3) !\u003d null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d mAB.group(4) !\u003d null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index \u0027%s\u0027: unexpected format\", argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (ofType)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\telse {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_1630946844",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "\tprivate void cssNthChild(boolean backwards, boolean ofType) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_1070456040",
      "lines": [
        {
          "code": "\t\tString argS \u003d normalize(tq.chompTo(\")\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mAB \u003d NTH_AB.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mB \u003d NTH_B.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tfinal int a, b;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (\"odd\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 1;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (\"even\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mAB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d mAB.group(3) !\u003d null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d mAB.group(4) !\u003d null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index \u0027%s\u0027: unexpected format\", argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (ofType)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\telse {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-110710668",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-2049407139",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_536145001",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-816342924",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1250430651",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-1454760370",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "\t\tpublic IsFirstOfType() {",
      "className": "org.jsoup.select.Evaluator.IsFirstOfType",
      "id": "MethodSignatureBackedByPsiMethod: IsFirstOfType([])_-62998586",
      "lines": [
        {
          "code": "\t\t\tsuper(0,1);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1904790854",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_1104607566",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "\t\tpublic IsLastOfType() {",
      "className": "org.jsoup.select.Evaluator.IsLastOfType",
      "id": "MethodSignatureBackedByPsiMethod: IsLastOfType([])_-901190648",
      "lines": [
        {
          "code": "\t\t\tsuper(0,1);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1873467249",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-1768063770",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-755202277",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-37226251",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1571594164",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_1189777386",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_1541945674",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-1392220289",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_555679561",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-96527233",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public SelectorParseException(String msg, Object... params) {",
      "className": "org.jsoup.select.Selector.SelectorParseException",
      "id": "MethodSignatureBackedByPsiMethod: SelectorParseException([PsiType:String, PsiType:Object[]])_-585942985",
      "lines": [
        {
          "code": "            super(String.format(msg, params));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public String remainder() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: remainder([])_-1052807761",
      "lines": [
        {
          "code": "        final String remainder \u003d queue.substring(pos);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        pos \u003d queue.length();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        return remainder;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private int remainingLength() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: remainingLength([])_873514853",
      "lines": [
        {
          "code": "        return queue.length() - pos;",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchesWhitespace() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchesWhitespace([])_667170665",
      "lines": [
        {
          "code": "        return !isEmpty() \u0026\u0026 StringUtil.isWhitespace(queue.charAt(pos));",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-2039003399",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean consumeWhitespace() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: consumeWhitespace([])_-1293171433",
      "lines": [
        {
          "code": "        boolean seen \u003d false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        while (matchesWhitespace()) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos++;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            seen \u003d true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return seen;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private String consumeSubQuery() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: consumeSubQuery([])_1644435498",
      "lines": [
        {
          "code": "        StringBuilder sq \u003d StringUtil.borrowBuilder();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        while (!tq.isEmpty()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (tq.matches(\"(\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                sq.append(\"(\").append(tq.chompBalanced(\u0027(\u0027, \u0027)\u0027)).append(\")\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (tq.matches(\"[\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                sq.append(\"[\").append(tq.chompBalanced(\u0027[\u0027, \u0027]\u0027)).append(\"]\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (tq.matchesAny(combinators))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                sq.append(tq.consume());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return StringUtil.releaseBuilder(sq);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public static Evaluator parse(String query) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_-1469241858",
      "lines": [
        {
          "code": "        try {",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            QueryParser p \u003d new QueryParser(query);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return p.parse();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        } catch (IllegalArgumentException e) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            throw new Selector.SelectorParseException(e.getMessage());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "size",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: size([])_-280924270",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "get",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_-1620593422",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    @Nullable Evaluator rightMostEvaluator() {",
      "className": "org.jsoup.select.CombiningEvaluator",
      "id": "MethodSignatureBackedByPsiMethod: rightMostEvaluator([])_-2015782882",
      "lines": [
        {
          "code": "        return num \u003e 0 ? evaluators.get(num - 1) : null;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Collection\u003cEvaluator\u003e evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Collection\u003cEvaluator\u003e])_36368104",
      "lines": [
        {
          "code": "            super(evaluators);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "clear",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: clear([])_-611926431",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Evaluator... evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_1045109385",
      "lines": [
        {
          "code": "            this(Arrays.asList(evaluators));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public ImmediateParent(Evaluator evaluator) {",
      "className": "org.jsoup.select.StructuralEvaluator.ImmediateParent",
      "id": "MethodSignatureBackedByPsiMethod: ImmediateParent([PsiType:Evaluator])_-630546600",
      "lines": [
        {
          "code": "            this.evaluator \u003d evaluator;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Evaluator... evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_-2034126039",
      "lines": [
        {
          "code": "            this(Arrays.asList(evaluators));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public Parent(Evaluator evaluator) {",
      "className": "org.jsoup.select.StructuralEvaluator.Parent",
      "id": "MethodSignatureBackedByPsiMethod: Parent([PsiType:Evaluator])_-1832599333",
      "lines": [
        {
          "code": "            this.evaluator \u003d evaluator;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Evaluator... evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_232985559",
      "lines": [
        {
          "code": "            this(Arrays.asList(evaluators));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public ImmediatePreviousSibling(Evaluator evaluator) {",
      "className": "org.jsoup.select.StructuralEvaluator.ImmediatePreviousSibling",
      "id": "MethodSignatureBackedByPsiMethod: ImmediatePreviousSibling([PsiType:Evaluator])_2041591637",
      "lines": [
        {
          "code": "            this.evaluator \u003d evaluator;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Evaluator... evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_-1263791265",
      "lines": [
        {
          "code": "            this(Arrays.asList(evaluators));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public PreviousSibling(Evaluator evaluator) {",
      "className": "org.jsoup.select.StructuralEvaluator.PreviousSibling",
      "id": "MethodSignatureBackedByPsiMethod: PreviousSibling([PsiType:Evaluator])_-1067533446",
      "lines": [
        {
          "code": "            this.evaluator \u003d evaluator;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        Or() {",
      "className": "org.jsoup.select.CombiningEvaluator.Or",
      "id": "MethodSignatureBackedByPsiMethod: Or([])_-1142214545",
      "lines": [
        {
          "code": "            super();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public void add(Evaluator e) {",
      "className": "org.jsoup.select.CombiningEvaluator.Or",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:Evaluator])_867812363",
      "lines": [
        {
          "code": "            evaluators.add(e);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            updateNumEvaluators();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public void add(Evaluator e) {",
      "className": "org.jsoup.select.CombiningEvaluator.Or",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:Evaluator])_209265993",
      "lines": [
        {
          "code": "            evaluators.add(e);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            updateNumEvaluators();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public SelectorParseException(String msg, Object... params) {",
      "className": "org.jsoup.select.Selector.SelectorParseException",
      "id": "MethodSignatureBackedByPsiMethod: SelectorParseException([PsiType:String, PsiType:Object[]])_-2065446156",
      "lines": [
        {
          "code": "            super(String.format(msg, params));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    void replaceRightMostEvaluator(Evaluator replacement) {",
      "className": "org.jsoup.select.CombiningEvaluator",
      "id": "MethodSignatureBackedByPsiMethod: replaceRightMostEvaluator([PsiType:Evaluator])_909003933",
      "lines": [
        {
          "code": "        evaluators.set(num - 1, replacement);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_1530702399",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "charAt",
      "className": "java.lang.String",
      "id": "MethodSignatureBackedByPsiMethod: charAt([PsiType:int])_-1462387319",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean consumeWhitespace() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: consumeWhitespace([])_-2097584976",
      "lines": [
        {
          "code": "        boolean seen \u003d false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        while (matchesWhitespace()) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos++;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            seen \u003d true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return seen;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private String consumeSubQuery() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: consumeSubQuery([])_-591955252",
      "lines": [
        {
          "code": "        StringBuilder sq \u003d StringUtil.borrowBuilder();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        while (!tq.isEmpty()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (tq.matches(\"(\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                sq.append(\"(\").append(tq.chompBalanced(\u0027(\u0027, \u0027)\u0027)).append(\")\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (tq.matches(\"[\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                sq.append(\"[\").append(tq.chompBalanced(\u0027[\u0027, \u0027]\u0027)).append(\"]\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (tq.matchesAny(combinators))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                break;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                sq.append(tq.consume());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        return StringUtil.releaseBuilder(sq);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public static Evaluator parse(String query) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_-129530093",
      "lines": [
        {
          "code": "        try {",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            QueryParser p \u003d new QueryParser(query);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return p.parse();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        } catch (IllegalArgumentException e) {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            throw new Selector.SelectorParseException(e.getMessage());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "size",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: size([])_-1824910933",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "get",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_-1064768907",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    @Nullable Evaluator rightMostEvaluator() {",
      "className": "org.jsoup.select.CombiningEvaluator",
      "id": "MethodSignatureBackedByPsiMethod: rightMostEvaluator([])_-1763860698",
      "lines": [
        {
          "code": "        return num \u003e 0 ? evaluators.get(num - 1) : null;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Collection\u003cEvaluator\u003e evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Collection\u003cEvaluator\u003e])_-549925662",
      "lines": [
        {
          "code": "            super(evaluators);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "clear",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: clear([])_-2025785755",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Evaluator... evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_-1819916956",
      "lines": [
        {
          "code": "            this(Arrays.asList(evaluators));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public ImmediateParent(Evaluator evaluator) {",
      "className": "org.jsoup.select.StructuralEvaluator.ImmediateParent",
      "id": "MethodSignatureBackedByPsiMethod: ImmediateParent([PsiType:Evaluator])_-2080726655",
      "lines": [
        {
          "code": "            this.evaluator \u003d evaluator;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Evaluator... evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_1002559824",
      "lines": [
        {
          "code": "            this(Arrays.asList(evaluators));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public Parent(Evaluator evaluator) {",
      "className": "org.jsoup.select.StructuralEvaluator.Parent",
      "id": "MethodSignatureBackedByPsiMethod: Parent([PsiType:Evaluator])_-1690419680",
      "lines": [
        {
          "code": "            this.evaluator \u003d evaluator;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Evaluator... evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_479247400",
      "lines": [
        {
          "code": "            this(Arrays.asList(evaluators));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public ImmediatePreviousSibling(Evaluator evaluator) {",
      "className": "org.jsoup.select.StructuralEvaluator.ImmediatePreviousSibling",
      "id": "MethodSignatureBackedByPsiMethod: ImmediatePreviousSibling([PsiType:Evaluator])_1112103289",
      "lines": [
        {
          "code": "            this.evaluator \u003d evaluator;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        And(Evaluator... evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator.And",
      "id": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_146593948",
      "lines": [
        {
          "code": "            this(Arrays.asList(evaluators));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public PreviousSibling(Evaluator evaluator) {",
      "className": "org.jsoup.select.StructuralEvaluator.PreviousSibling",
      "id": "MethodSignatureBackedByPsiMethod: PreviousSibling([PsiType:Evaluator])_-637666377",
      "lines": [
        {
          "code": "            this.evaluator \u003d evaluator;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        Or() {",
      "className": "org.jsoup.select.CombiningEvaluator.Or",
      "id": "MethodSignatureBackedByPsiMethod: Or([])_403601515",
      "lines": [
        {
          "code": "            super();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public void add(Evaluator e) {",
      "className": "org.jsoup.select.CombiningEvaluator.Or",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:Evaluator])_1349753049",
      "lines": [
        {
          "code": "            evaluators.add(e);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            updateNumEvaluators();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public void add(Evaluator e) {",
      "className": "org.jsoup.select.CombiningEvaluator.Or",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:Evaluator])_-2094200265",
      "lines": [
        {
          "code": "            evaluators.add(e);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            updateNumEvaluators();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public SelectorParseException(String msg, Object... params) {",
      "className": "org.jsoup.select.Selector.SelectorParseException",
      "id": "MethodSignatureBackedByPsiMethod: SelectorParseException([PsiType:String, PsiType:Object[]])_133082493",
      "lines": [
        {
          "code": "            super(String.format(msg, params));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    void replaceRightMostEvaluator(Evaluator replacement) {",
      "className": "org.jsoup.select.CombiningEvaluator",
      "id": "MethodSignatureBackedByPsiMethod: replaceRightMostEvaluator([PsiType:Evaluator])_-747212917",
      "lines": [
        {
          "code": "        evaluators.set(num - 1, replacement);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-2096367554",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_2082880154",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void byId() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: byId([])_-1584098172",
      "lines": [
        {
          "code": "        String id \u003d tq.consumeCssIdentifier();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(id);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.add(new Evaluator.Id(id));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1887198579",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void byClass() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: byClass([])_1824868862",
      "lines": [
        {
          "code": "        String className \u003d tq.consumeCssIdentifier();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(className);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.add(new Evaluator.Class(className.trim()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchesWord() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchesWord([])_735151700",
      "lines": [
        {
          "code": "        return !isEmpty() \u0026\u0026 Character.isLetterOrDigit(queue.charAt(pos));",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_709147676",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void byTag() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: byTag([])_1950869841",
      "lines": [
        {
          "code": "        // todo - these aren\u0027t dealing perfectly with case sensitivity. For case sensitive parsers, we should also make",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        // the tag in the selector case-sensitive (and also attribute names). But for now, normalize (lower-case) for",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        // consistency - both the selector and the element tag",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String tagName \u003d normalize(tq.consumeElementSelector());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(tagName);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        // namespaces: wildcard match equals(tagName) or ending in \":\"+tagName",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (tagName.startsWith(\"*|\")) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new CombiningEvaluator.Or(new Evaluator.Tag(tagName), new Evaluator.TagEndsWith(tagName.replace(\"*|\", \":\"))));",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (tagName.contains(\"|\"))",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "                tagName \u003d tagName.replace(\"|\", \":\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.Tag(tagName));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1728850107",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void byAttribute() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: byAttribute([])_-862799262",
      "lines": [
        {
          "code": "        TokenQueue cq \u003d new TokenQueue(tq.chompBalanced(\u0027[\u0027, \u0027]\u0027)); // content queue",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String key \u003d cq.consumeToAny(AttributeEvals); // eq, not, start, end, contain, match, (no val)",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(key);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        cq.consumeWhitespace();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (cq.isEmpty()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (key.startsWith(\"^\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.AttributeStarting(key.substring(1)));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.Attribute(key));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            if (cq.matchChomp(\"\u003d\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.AttributeWithValue(key, cq.remainder()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (cq.matchChomp(\"!\u003d\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.AttributeWithValueNot(key, cq.remainder()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (cq.matchChomp(\"^\u003d\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (cq.matchChomp(\"$\u003d\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (cq.matchChomp(\"*\u003d\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else if (cq.matchChomp(\"~\u003d\"))",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                evals.add(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "                throw new Selector.SelectorParseException(\"Could not parse attribute query \u0027%s\u0027: unexpected token at \u0027%s\u0027\", query, cq.remainder());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_1963619738",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void allElements() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: allElements([])_-658260729",
      "lines": [
        {
          "code": "        evals.add(new Evaluator.AllElements());",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1576875135",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void indexLessThan() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: indexLessThan([])_1639114178",
      "lines": [
        {
          "code": "        evals.add(new Evaluator.IndexLessThan(consumeIndex()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_109202522",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void indexGreaterThan() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: indexGreaterThan([])_269202913",
      "lines": [
        {
          "code": "        evals.add(new Evaluator.IndexGreaterThan(consumeIndex()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_860516863",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void indexEquals() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: indexEquals([])_103411786",
      "lines": [
        {
          "code": "        evals.add(new Evaluator.IndexEquals(consumeIndex()));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1583237626",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void has() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: has([])_962310154",
      "lines": [
        {
          "code": "        tq.consume(\":has\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String subQuery \u003d tq.chompBalanced(\u0027(\u0027, \u0027)\u0027);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.add(new StructuralEvaluator.Has(parse(subQuery)));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_2103060950",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void contains(boolean own) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: contains([PsiType:boolean])_1869236917",
      "lines": [
        {
          "code": "        tq.consume(own ? \":containsOwn\" : \":contains\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String searchText \u003d TokenQueue.unescape(tq.chompBalanced(\u0027(\u0027, \u0027)\u0027));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (own)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.ContainsOwnText(searchText));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.ContainsText(searchText));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1559035113",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void contains(boolean own) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: contains([PsiType:boolean])_-234697770",
      "lines": [
        {
          "code": "        tq.consume(own ? \":containsOwn\" : \":contains\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String searchText \u003d TokenQueue.unescape(tq.chompBalanced(\u0027(\u0027, \u0027)\u0027));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (own)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.ContainsOwnText(searchText));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.ContainsText(searchText));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_1200829443",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void containsData() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: containsData([])_-1028715522",
      "lines": [
        {
          "code": "        tq.consume(\":containsData\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String searchText \u003d TokenQueue.unescape(tq.chompBalanced(\u0027(\u0027, \u0027)\u0027));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(searchText, \":containsData(text) query must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.add(new Evaluator.ContainsData(searchText));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-482258021",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void matches(boolean own) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:boolean])_-283984583",
      "lines": [
        {
          "code": "        tq.consume(own ? \":matchesOwn\" : \":matches\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String regex \u003d tq.chompBalanced(\u0027(\u0027, \u0027)\u0027); // don\u0027t unescape, as regex bits will be escaped",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (own)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.MatchesOwn(Pattern.compile(regex)));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.Matches(Pattern.compile(regex)));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1205878827",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void matches(boolean own) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:boolean])_-763490320",
      "lines": [
        {
          "code": "        tq.consume(own ? \":matchesOwn\" : \":matches\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String regex \u003d tq.chompBalanced(\u0027(\u0027, \u0027)\u0027); // don\u0027t unescape, as regex bits will be escaped",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        if (own)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.MatchesOwn(Pattern.compile(regex)));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        else",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            evals.add(new Evaluator.Matches(Pattern.compile(regex)));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matches(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_1453888569",
      "lines": [
        {
          "code": "        return queue.regionMatches(true, pos, seq, 0, seq.length());",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    private void not() {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: not([])_-730849667",
      "lines": [
        {
          "code": "        tq.consume(\":not\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        String subQuery \u003d tq.chompBalanced(\u0027(\u0027, \u0027)\u0027);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        evals.add(new StructuralEvaluator.Not(parse(subQuery)));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-433858165",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "\tprivate void cssNthChild(boolean backwards, boolean ofType) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_-1961563394",
      "lines": [
        {
          "code": "\t\tString argS \u003d normalize(tq.chompTo(\")\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mAB \u003d NTH_AB.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mB \u003d NTH_B.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tfinal int a, b;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (\"odd\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 1;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (\"even\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mAB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d mAB.group(3) !\u003d null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d mAB.group(4) !\u003d null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index \u0027%s\u0027: unexpected format\", argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (ofType)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\telse {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1162229902",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "\tprivate void cssNthChild(boolean backwards, boolean ofType) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_1854454319",
      "lines": [
        {
          "code": "\t\tString argS \u003d normalize(tq.chompTo(\")\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mAB \u003d NTH_AB.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mB \u003d NTH_B.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tfinal int a, b;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (\"odd\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 1;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (\"even\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mAB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d mAB.group(3) !\u003d null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d mAB.group(4) !\u003d null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index \u0027%s\u0027: unexpected format\", argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (ofType)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\telse {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-138666181",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "\tprivate void cssNthChild(boolean backwards, boolean ofType) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_143705935",
      "lines": [
        {
          "code": "\t\tString argS \u003d normalize(tq.chompTo(\")\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mAB \u003d NTH_AB.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mB \u003d NTH_B.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tfinal int a, b;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (\"odd\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 1;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (\"even\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mAB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d mAB.group(3) !\u003d null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d mAB.group(4) !\u003d null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index \u0027%s\u0027: unexpected format\", argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (ofType)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\telse {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-68935895",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "\tprivate void cssNthChild(boolean backwards, boolean ofType) {",
      "className": "org.jsoup.select.QueryParser",
      "id": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_1322254426",
      "lines": [
        {
          "code": "\t\tString argS \u003d normalize(tq.chompTo(\")\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mAB \u003d NTH_AB.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tMatcher mB \u003d NTH_B.matcher(argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tfinal int a, b;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (\"odd\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 1;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (\"even\".equals(argS)) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 2;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mAB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d mAB.group(3) !\u003d null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d mAB.group(4) !\u003d null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else if (mB.matches()) {",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\ta \u003d 0;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tb \u003d Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t} else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index \u0027%s\u0027: unexpected format\", argS);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\tif (ofType)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthOfType(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\telse {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\tif (backwards)",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthLastChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\telse",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t\t\tevals.add(new Evaluator.IsNthChild(a, b));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "\t\t}",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1204264972",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_638484253",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_458730084",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-1334764809",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_1765706023",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_2063697983",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "\t\tpublic IsFirstOfType() {",
      "className": "org.jsoup.select.Evaluator.IsFirstOfType",
      "id": "MethodSignatureBackedByPsiMethod: IsFirstOfType([])_-1457611948",
      "lines": [
        {
          "code": "\t\t\tsuper(0,1);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_766072227",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-446396862",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "\t\tpublic IsLastOfType() {",
      "className": "org.jsoup.select.Evaluator.IsLastOfType",
      "id": "MethodSignatureBackedByPsiMethod: IsLastOfType([])_-1193966333",
      "lines": [
        {
          "code": "\t\t\tsuper(0,1);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_628517266",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-701182830",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1298794851",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_1205308993",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_186799275",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_2137167555",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_948231577",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_1285655212",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public boolean matchChomp(String seq) {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-402322722",
      "lines": [
        {
          "code": "        if (matches(seq)) {",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "            pos +\u003d seq.length();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return true;",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        } else {",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "            return false;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        }",
          "callsMethod": false,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "add",
      "className": "java.util.List",
      "id": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-33235083",
      "lines": [],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "        public SelectorParseException(String msg, Object... params) {",
      "className": "org.jsoup.select.Selector.SelectorParseException",
      "id": "MethodSignatureBackedByPsiMethod: SelectorParseException([PsiType:String, PsiType:Object[]])_833794310",
      "lines": [
        {
          "code": "            super(String.format(msg, params));",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    public String remainder() {",
      "className": "org.jsoup.parser.TokenQueue",
      "id": "MethodSignatureBackedByPsiMethod: remainder([])_-401397909",
      "lines": [
        {
          "code": "        final String remainder \u003d queue.substring(pos);",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        pos \u003d queue.length();",
          "callsMethod": true,
          "covered": true,
          "addCovered": false
        },
        {
          "code": "        return remainder;",
          "callsMethod": false,
          "covered": true,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    },
    {
      "signature": "    CombiningEvaluator(Collection\u003cEvaluator\u003e evaluators) {",
      "className": "org.jsoup.select.CombiningEvaluator",
      "id": "MethodSignatureBackedByPsiMethod: CombiningEvaluator([PsiType:Collection\u003cEvaluator\u003e])_-907577309",
      "lines": [
        {
          "code": "        this();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        this.evaluators.addAll(evaluators);",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        },
        {
          "code": "        updateNumEvaluators();",
          "callsMethod": true,
          "covered": false,
          "addCovered": false
        }
      ],
      "addCovered": false,
      "nodeLevel": 5
    }
  ],
  "edges": [
    {
      "source": "root",
      "target": "MethodSignatureBackedByPsiMethod: \u003cT\u003eassertThrows([PsiType:Class\u003cT\u003e, PsiType:Executable])_1926352775",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "root",
      "target": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_1866495644",
      "sourceAnchor": 3,
      "targetAnchor": 0
    },
    {
      "source": "root",
      "target": "MethodSignatureBackedByPsiMethod: getElementsByTag([PsiType:String])_1150471544",
      "sourceAnchor": 4,
      "targetAnchor": 0
    },
    {
      "source": "root",
      "target": "MethodSignatureBackedByPsiMethod: size([])_391889604",
      "sourceAnchor": 5,
      "targetAnchor": 0
    },
    {
      "source": "root",
      "target": "MethodSignatureBackedByPsiMethod: id([])_70465572",
      "sourceAnchor": 6,
      "targetAnchor": 0
    },
    {
      "source": "root",
      "target": "MethodSignatureBackedByPsiMethod: first([])_-1145293840",
      "sourceAnchor": 6,
      "targetAnchor": 0
    },
    {
      "source": "root",
      "target": "MethodSignatureBackedByPsiMethod: tagName([])_2016545588",
      "sourceAnchor": 7,
      "targetAnchor": 0
    },
    {
      "source": "root",
      "target": "MethodSignatureBackedByPsiMethod: first([])_-135852916",
      "sourceAnchor": 7,
      "targetAnchor": 0
    },
    {
      "source": "root",
      "target": "MethodSignatureBackedByPsiMethod: is([PsiType:String])_-303853799",
      "sourceAnchor": 8,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_1866495644",
      "target": "MethodSignatureBackedByPsiMethod: parse([PsiType:String, PsiType:String])_-1056017478",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: getElementsByTag([PsiType:String])_1150471544",
      "target": "MethodSignatureBackedByPsiMethod: notEmpty([PsiType:String])_-256522515",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: getElementsByTag([PsiType:String])_1150471544",
      "target": "MethodSignatureBackedByPsiMethod: normalize([PsiType:String])_1481438275",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: getElementsByTag([PsiType:String])_1150471544",
      "target": "MethodSignatureBackedByPsiMethod: collect([PsiType:Evaluator, PsiType:Element])_-2138536365",
      "sourceAnchor": 4,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: getElementsByTag([PsiType:String])_1150471544",
      "target": "MethodSignatureBackedByPsiMethod: Tag([PsiType:String])_-783416539",
      "sourceAnchor": 4,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: id([])_70465572",
      "target": "MethodSignatureBackedByPsiMethod: getIgnoreCase([PsiType:String])_-1710959840",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: first([])_-1145293840",
      "target": "MethodSignatureBackedByPsiMethod: isEmpty([])_-86325364",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: first([])_-1145293840",
      "target": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_1593892113",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: tagName([])_2016545588",
      "target": "MethodSignatureBackedByPsiMethod: getName([])_-495737043",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: first([])_-135852916",
      "target": "MethodSignatureBackedByPsiMethod: isEmpty([])_1447658979",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: first([])_-135852916",
      "target": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_-1129142944",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: is([PsiType:String])_-303853799",
      "target": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_924335745",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: is([PsiType:String])_-303853799",
      "target": "MethodSignatureBackedByPsiMethod: is([PsiType:Evaluator])_1143423091",
      "sourceAnchor": 3,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([PsiType:String, PsiType:String])_-1056017478",
      "target": "MethodSignatureBackedByPsiMethod: parse([PsiType:Reader, PsiType:String, PsiType:Parser])_-1813351896",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([PsiType:String, PsiType:String])_-1056017478",
      "target": "MethodSignatureBackedByPsiMethod: StringReader([PsiType:String])_-1445627906",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([PsiType:String, PsiType:String])_-1056017478",
      "target": "MethodSignatureBackedByPsiMethod: Parser([PsiType:TreeBuilder])_1162340011",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: notEmpty([PsiType:String])_-256522515",
      "target": "MethodSignatureBackedByPsiMethod: length([])_-2028283825",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: notEmpty([PsiType:String])_-256522515",
      "target": "MethodSignatureBackedByPsiMethod: IllegalArgumentException([PsiType:String])_58650947",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: normalize([PsiType:String])_1481438275",
      "target": "MethodSignatureBackedByPsiMethod: trim([])_1736317472",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: normalize([PsiType:String])_1481438275",
      "target": "MethodSignatureBackedByPsiMethod: lowerCase([PsiType:String])_-454938226",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: collect([PsiType:Evaluator, PsiType:Element])_-2138536365",
      "target": "MethodSignatureBackedByPsiMethod: Elements([])_794880811",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: collect([PsiType:Evaluator, PsiType:Element])_-2138536365",
      "target": "MethodSignatureBackedByPsiMethod: traverse([PsiType:NodeVisitor, PsiType:Node])_1791246505",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: collect([PsiType:Evaluator, PsiType:Element])_-2138536365",
      "target": "MethodSignatureBackedByPsiMethod: Accumulator([PsiType:Element, PsiType:Elements, PsiType:Evaluator])_-1477633170",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: getIgnoreCase([PsiType:String])_-1710959840",
      "target": "MethodSignatureBackedByPsiMethod: indexOfKeyIgnoreCase([PsiType:String])_-1555728248",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: getIgnoreCase([PsiType:String])_-1710959840",
      "target": "MethodSignatureBackedByPsiMethod: checkNotNull([PsiType:String])_1680638990",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_924335745",
      "target": "MethodSignatureBackedByPsiMethod: QueryParser([PsiType:String])_-694142982",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_924335745",
      "target": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "sourceAnchor": 3,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_924335745",
      "target": "MethodSignatureBackedByPsiMethod: SelectorParseException([PsiType:String, PsiType:Object[]])_-275455494",
      "sourceAnchor": 5,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_924335745",
      "target": "MethodSignatureBackedByPsiMethod: getMessage([])_1866399095",
      "sourceAnchor": 5,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: is([PsiType:Evaluator])_1143423091",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:Element, PsiType:Element])_327867200",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: is([PsiType:Evaluator])_1143423091",
      "target": "MethodSignatureBackedByPsiMethod: root([])_-1608198050",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([PsiType:Reader, PsiType:String, PsiType:Parser])_-1813351896",
      "target": "MethodSignatureBackedByPsiMethod: initialiseParse([PsiType:Reader, PsiType:String, PsiType:Parser])_1195116331",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([PsiType:Reader, PsiType:String, PsiType:Parser])_-1813351896",
      "target": "MethodSignatureBackedByPsiMethod: runParser([])_-1640989844",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([PsiType:Reader, PsiType:String, PsiType:Parser])_-1813351896",
      "target": "MethodSignatureBackedByPsiMethod: close([])_-1719120519",
      "sourceAnchor": 5,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: Parser([PsiType:TreeBuilder])_1162340011",
      "target": "MethodSignatureBackedByPsiMethod: defaultSettings([])_-812996206",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: Parser([PsiType:TreeBuilder])_1162340011",
      "target": "MethodSignatureBackedByPsiMethod: noTracking([])_-2073258899",
      "sourceAnchor": 3,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: lowerCase([PsiType:String])_-454938226",
      "target": "MethodSignatureBackedByPsiMethod: toLowerCase([PsiType:Locale])_1694331601",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: traverse([PsiType:NodeVisitor, PsiType:Node])_1791246505",
      "target": "MethodSignatureBackedByPsiMethod: parentNode([])_57730898",
      "sourceAnchor": 6,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: traverse([PsiType:NodeVisitor, PsiType:Node])_1791246505",
      "target": "MethodSignatureBackedByPsiMethod: head([PsiType:Node, PsiType:int])_113617089",
      "sourceAnchor": 7,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: traverse([PsiType:NodeVisitor, PsiType:Node])_1791246505",
      "target": "MethodSignatureBackedByPsiMethod: hasParent([])_-183285891",
      "sourceAnchor": 8,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: traverse([PsiType:NodeVisitor, PsiType:Node])_1791246505",
      "target": "MethodSignatureBackedByPsiMethod: childNode([PsiType:int])_2098516477",
      "sourceAnchor": 9,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: traverse([PsiType:NodeVisitor, PsiType:Node])_1791246505",
      "target": "MethodSignatureBackedByPsiMethod: siblingIndex([])_-1059228107",
      "sourceAnchor": 9,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: traverse([PsiType:NodeVisitor, PsiType:Node])_1791246505",
      "target": "MethodSignatureBackedByPsiMethod: childNodeSize([])_-1244893490",
      "sourceAnchor": 11,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: traverse([PsiType:NodeVisitor, PsiType:Node])_1791246505",
      "target": "MethodSignatureBackedByPsiMethod: childNode([PsiType:int])_11792431",
      "sourceAnchor": 12,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: traverse([PsiType:NodeVisitor, PsiType:Node])_1791246505",
      "target": "MethodSignatureBackedByPsiMethod: nextSibling([])_-70803830",
      "sourceAnchor": 17,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: traverse([PsiType:NodeVisitor, PsiType:Node])_1791246505",
      "target": "MethodSignatureBackedByPsiMethod: tail([PsiType:Node, PsiType:int])_1122625413",
      "sourceAnchor": 18,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: traverse([PsiType:NodeVisitor, PsiType:Node])_1791246505",
      "target": "MethodSignatureBackedByPsiMethod: parentNode([])_1009898624",
      "sourceAnchor": 19,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: traverse([PsiType:NodeVisitor, PsiType:Node])_1791246505",
      "target": "MethodSignatureBackedByPsiMethod: tail([PsiType:Node, PsiType:int])_678582090",
      "sourceAnchor": 22,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: traverse([PsiType:NodeVisitor, PsiType:Node])_1791246505",
      "target": "MethodSignatureBackedByPsiMethod: nextSibling([])_-407626644",
      "sourceAnchor": 25,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: indexOfKeyIgnoreCase([PsiType:String])_-1555728248",
      "target": "MethodSignatureBackedByPsiMethod: notNull([PsiType:Object])_1046537256",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: indexOfKeyIgnoreCase([PsiType:String])_-1555728248",
      "target": "MethodSignatureBackedByPsiMethod: equalsIgnoreCase([PsiType:String])_421446078",
      "sourceAnchor": 3,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: QueryParser([PsiType:String])_-694142982",
      "target": "MethodSignatureBackedByPsiMethod: notEmpty([PsiType:String])_8925104",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: QueryParser([PsiType:String])_-694142982",
      "target": "MethodSignatureBackedByPsiMethod: trim([])_-338439612",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: QueryParser([PsiType:String])_-694142982",
      "target": "MethodSignatureBackedByPsiMethod: TokenQueue([PsiType:String])_1443307589",
      "sourceAnchor": 4,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: consumeWhitespace([])_-1749206023",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: matchesAny([PsiType:String[]])_-1278839358",
      "sourceAnchor": 3,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_963968758",
      "sourceAnchor": 4,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "sourceAnchor": 5,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: consume([])_1688299496",
      "sourceAnchor": 5,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "sourceAnchor": 7,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: isEmpty([])_501044344",
      "sourceAnchor": 10,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: consumeWhitespace([])_1759284288",
      "sourceAnchor": 12,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: matchesAny([PsiType:String[]])_1750364795",
      "sourceAnchor": 14,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "sourceAnchor": 15,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: consume([])_-35845139",
      "sourceAnchor": 15,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "sourceAnchor": 17,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "sourceAnchor": 19,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: size([])_-886360486",
      "sourceAnchor": 23,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_1584834289",
      "sourceAnchor": 24,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: parse([])_684185655",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Collection\u003cEvaluator\u003e])_-1830821654",
      "sourceAnchor": 26,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: SelectorParseException([PsiType:String, PsiType:Object[]])_-275455494",
      "target": "MethodSignatureBackedByPsiMethod: IllegalStateException([PsiType:String])_670869707",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: SelectorParseException([PsiType:String, PsiType:Object[]])_-275455494",
      "target": "MethodSignatureBackedByPsiMethod: format([PsiType:String, PsiType:Object[]])_147965286",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: root([])_-1608198050",
      "target": "MethodSignatureBackedByPsiMethod: root([])_-13569482",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: initialiseParse([PsiType:Reader, PsiType:String, PsiType:Parser])_1195116331",
      "target": "MethodSignatureBackedByPsiMethod: notNull([PsiType:Object, PsiType:String])_1404977726",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: initialiseParse([PsiType:Reader, PsiType:String, PsiType:Parser])_1195116331",
      "target": "MethodSignatureBackedByPsiMethod: notNull([PsiType:Object, PsiType:String])_-2119631475",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: initialiseParse([PsiType:Reader, PsiType:String, PsiType:Parser])_1195116331",
      "target": "MethodSignatureBackedByPsiMethod: notNull([PsiType:Object])_1850795666",
      "sourceAnchor": 3,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: initialiseParse([PsiType:Reader, PsiType:String, PsiType:Parser])_1195116331",
      "target": "MethodSignatureBackedByPsiMethod: Document([PsiType:String])_1173232975",
      "sourceAnchor": 5,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: initialiseParse([PsiType:Reader, PsiType:String, PsiType:Parser])_1195116331",
      "target": "MethodSignatureBackedByPsiMethod: parser([PsiType:Parser])_-1334598918",
      "sourceAnchor": 6,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: initialiseParse([PsiType:Reader, PsiType:String, PsiType:Parser])_1195116331",
      "target": "MethodSignatureBackedByPsiMethod: settings([])_-160012383",
      "sourceAnchor": 8,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: initialiseParse([PsiType:Reader, PsiType:String, PsiType:Parser])_1195116331",
      "target": "MethodSignatureBackedByPsiMethod: CharacterReader([PsiType:Reader])_-849971096",
      "sourceAnchor": 9,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: initialiseParse([PsiType:Reader, PsiType:String, PsiType:Parser])_1195116331",
      "target": "MethodSignatureBackedByPsiMethod: Tokeniser([PsiType:CharacterReader, PsiType:ParseErrorList])_-562299956",
      "sourceAnchor": 11,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: initialiseParse([PsiType:Reader, PsiType:String, PsiType:Parser])_1195116331",
      "target": "MethodSignatureBackedByPsiMethod: getErrors([])_1543974038",
      "sourceAnchor": 11,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: initialiseParse([PsiType:Reader, PsiType:String, PsiType:Parser])_1195116331",
      "target": "MethodSignatureBackedByPsiMethod: ArrayList([PsiType:int])_-1016350441",
      "sourceAnchor": 12,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: runParser([])_-1640989844",
      "target": "MethodSignatureBackedByPsiMethod: read([])_1018338730",
      "sourceAnchor": 5,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: runParser([])_-1640989844",
      "target": "MethodSignatureBackedByPsiMethod: process([PsiType:Token])_1455342470",
      "sourceAnchor": 6,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: runParser([])_-1640989844",
      "target": "MethodSignatureBackedByPsiMethod: reset([])_1175472875",
      "sourceAnchor": 7,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: close([])_-1719120519",
      "target": "MethodSignatureBackedByPsiMethod: close([])_-292742612",
      "sourceAnchor": 4,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: noTracking([])_-2073258899",
      "target": "MethodSignatureBackedByPsiMethod: ParseErrorList([PsiType:int, PsiType:int])_-1349476676",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: childNode([PsiType:int])_2098516477",
      "target": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_479779899",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: childNode([PsiType:int])_2098516477",
      "target": "MethodSignatureBackedByPsiMethod: ensureChildNodes([])_-1353120194",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: childNode([PsiType:int])_11792431",
      "target": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_1619784959",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: childNode([PsiType:int])_11792431",
      "target": "MethodSignatureBackedByPsiMethod: ensureChildNodes([])_1427242307",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: nextSibling([])_-70803830",
      "target": "MethodSignatureBackedByPsiMethod: ensureChildNodes([])_-641231780",
      "sourceAnchor": 4,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: nextSibling([])_-70803830",
      "target": "MethodSignatureBackedByPsiMethod: size([])_482179452",
      "sourceAnchor": 6,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: nextSibling([])_-70803830",
      "target": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_282945674",
      "sourceAnchor": 7,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: nextSibling([])_-407626644",
      "target": "MethodSignatureBackedByPsiMethod: ensureChildNodes([])_437558792",
      "sourceAnchor": 4,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: nextSibling([])_-407626644",
      "target": "MethodSignatureBackedByPsiMethod: size([])_353750821",
      "sourceAnchor": 6,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: nextSibling([])_-407626644",
      "target": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_1419110599",
      "sourceAnchor": 7,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: notNull([PsiType:Object])_1046537256",
      "target": "MethodSignatureBackedByPsiMethod: IllegalArgumentException([PsiType:String])_1976596175",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: notEmpty([PsiType:String])_8925104",
      "target": "MethodSignatureBackedByPsiMethod: length([])_1518882",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: notEmpty([PsiType:String])_8925104",
      "target": "MethodSignatureBackedByPsiMethod: IllegalArgumentException([PsiType:String])_-322764818",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: TokenQueue([PsiType:String])_1443307589",
      "target": "MethodSignatureBackedByPsiMethod: notNull([PsiType:Object])_-875742159",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: consumeWhitespace([])_-1749206023",
      "target": "MethodSignatureBackedByPsiMethod: matchesWhitespace([])_1310483025",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: matchesAny([PsiType:String[]])_-1278839358",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1782767532",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: consumeWhitespace([])_-317847871",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: consumeSubQuery([])_1906172614",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_-739053883",
      "sourceAnchor": 6,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: size([])_-643433549",
      "sourceAnchor": 9,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_-1934048725",
      "sourceAnchor": 10,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: rightMostEvaluator([])_806052303",
      "sourceAnchor": 13,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Collection\u003cEvaluator\u003e])_-1305904887",
      "sourceAnchor": 19,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: clear([])_895597708",
      "sourceAnchor": 21,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_-514692521",
      "sourceAnchor": 26,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: ImmediateParent([PsiType:Evaluator])_-875621291",
      "sourceAnchor": 26,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_365369941",
      "sourceAnchor": 29,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: Parent([PsiType:Evaluator])_914787972",
      "sourceAnchor": 29,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_593758552",
      "sourceAnchor": 32,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: ImmediatePreviousSibling([PsiType:Evaluator])_-455942428",
      "sourceAnchor": 32,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_-797619536",
      "sourceAnchor": 35,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: PreviousSibling([PsiType:Evaluator])_-980799745",
      "sourceAnchor": 35,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: Or([])_-1334074171",
      "sourceAnchor": 42,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:Evaluator])_-2000888944",
      "sourceAnchor": 43,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:Evaluator])_1177794212",
      "sourceAnchor": 45,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: SelectorParseException([PsiType:String, PsiType:Object[]])_121873093",
      "sourceAnchor": 49,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: replaceRightMostEvaluator([PsiType:Evaluator])_1137175690",
      "sourceAnchor": 53,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_770007886",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_800801340",
      "sourceAnchor": 55,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: consume([])_1688299496",
      "target": "MethodSignatureBackedByPsiMethod: charAt([PsiType:int])_1502034996",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-316661277",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: byId([])_381649661",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1192226535",
      "sourceAnchor": 3,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: byClass([])_1885815566",
      "sourceAnchor": 4,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchesWord([])_-211788337",
      "sourceAnchor": 5,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-814992849",
      "sourceAnchor": 5,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: byTag([])_1943026029",
      "sourceAnchor": 6,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_816571388",
      "sourceAnchor": 7,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: byAttribute([])_1247905230",
      "sourceAnchor": 8,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_1923326596",
      "sourceAnchor": 9,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: allElements([])_-557689707",
      "sourceAnchor": 10,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1745710176",
      "sourceAnchor": 11,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: indexLessThan([])_-364401254",
      "sourceAnchor": 12,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1292081530",
      "sourceAnchor": 13,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: indexGreaterThan([])_763700557",
      "sourceAnchor": 14,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_1880507488",
      "sourceAnchor": 15,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: indexEquals([])_-40535490",
      "sourceAnchor": 16,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1293455371",
      "sourceAnchor": 17,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: has([])_329673005",
      "sourceAnchor": 18,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-508349538",
      "sourceAnchor": 19,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: contains([PsiType:boolean])_-241747643",
      "sourceAnchor": 20,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-968670686",
      "sourceAnchor": 21,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: contains([PsiType:boolean])_-1395212682",
      "sourceAnchor": 22,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1996630484",
      "sourceAnchor": 23,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: containsData([])_21349907",
      "sourceAnchor": 24,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1623231108",
      "sourceAnchor": 25,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:boolean])_-1502633458",
      "sourceAnchor": 26,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_699897855",
      "sourceAnchor": 27,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:boolean])_-1968709231",
      "sourceAnchor": 28,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_549216363",
      "sourceAnchor": 29,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: not([])_1061997001",
      "sourceAnchor": 30,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_344154913",
      "sourceAnchor": 31,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_637460496",
      "sourceAnchor": 32,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_1723595100",
      "sourceAnchor": 33,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_225074921",
      "sourceAnchor": 34,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-578346516",
      "sourceAnchor": 35,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_-1552559770",
      "sourceAnchor": 36,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_1630946844",
      "sourceAnchor": 37,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_1070456040",
      "sourceAnchor": 38,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-110710668",
      "sourceAnchor": 39,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-2049407139",
      "sourceAnchor": 40,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_536145001",
      "sourceAnchor": 41,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-816342924",
      "sourceAnchor": 42,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1250430651",
      "sourceAnchor": 43,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-1454760370",
      "sourceAnchor": 44,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: IsFirstOfType([])_-62998586",
      "sourceAnchor": 44,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1904790854",
      "sourceAnchor": 45,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_1104607566",
      "sourceAnchor": 46,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: IsLastOfType([])_-901190648",
      "sourceAnchor": 46,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1873467249",
      "sourceAnchor": 47,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-1768063770",
      "sourceAnchor": 48,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-755202277",
      "sourceAnchor": 49,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-37226251",
      "sourceAnchor": 50,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1571594164",
      "sourceAnchor": 51,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_1189777386",
      "sourceAnchor": 52,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_1541945674",
      "sourceAnchor": 53,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-1392220289",
      "sourceAnchor": 54,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_555679561",
      "sourceAnchor": 55,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-96527233",
      "sourceAnchor": 56,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: SelectorParseException([PsiType:String, PsiType:Object[]])_-585942985",
      "sourceAnchor": 58,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_-1564286718",
      "target": "MethodSignatureBackedByPsiMethod: remainder([])_-1052807761",
      "sourceAnchor": 58,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: isEmpty([])_501044344",
      "target": "MethodSignatureBackedByPsiMethod: remainingLength([])_873514853",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: consumeWhitespace([])_1759284288",
      "target": "MethodSignatureBackedByPsiMethod: matchesWhitespace([])_667170665",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: matchesAny([PsiType:String[]])_1750364795",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-2039003399",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: consumeWhitespace([])_-1293171433",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: consumeSubQuery([])_1644435498",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_-1469241858",
      "sourceAnchor": 6,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: size([])_-280924270",
      "sourceAnchor": 9,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_-1620593422",
      "sourceAnchor": 10,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: rightMostEvaluator([])_-2015782882",
      "sourceAnchor": 13,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Collection\u003cEvaluator\u003e])_36368104",
      "sourceAnchor": 19,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: clear([])_-611926431",
      "sourceAnchor": 21,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_1045109385",
      "sourceAnchor": 26,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: ImmediateParent([PsiType:Evaluator])_-630546600",
      "sourceAnchor": 26,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_-2034126039",
      "sourceAnchor": 29,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: Parent([PsiType:Evaluator])_-1832599333",
      "sourceAnchor": 29,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_232985559",
      "sourceAnchor": 32,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: ImmediatePreviousSibling([PsiType:Evaluator])_2041591637",
      "sourceAnchor": 32,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_-1263791265",
      "sourceAnchor": 35,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: PreviousSibling([PsiType:Evaluator])_-1067533446",
      "sourceAnchor": 35,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: Or([])_-1142214545",
      "sourceAnchor": 42,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:Evaluator])_867812363",
      "sourceAnchor": 43,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:Evaluator])_209265993",
      "sourceAnchor": 45,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: SelectorParseException([PsiType:String, PsiType:Object[]])_-2065446156",
      "sourceAnchor": 49,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: replaceRightMostEvaluator([PsiType:Evaluator])_909003933",
      "sourceAnchor": 53,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-1757918215",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_1530702399",
      "sourceAnchor": 55,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: consume([])_-35845139",
      "target": "MethodSignatureBackedByPsiMethod: charAt([PsiType:int])_-1462387319",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: consumeWhitespace([])_-2097584976",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: consumeSubQuery([])_-591955252",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: parse([PsiType:String])_-129530093",
      "sourceAnchor": 6,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: size([])_-1824910933",
      "sourceAnchor": 9,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: get([PsiType:int])_-1064768907",
      "sourceAnchor": 10,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: rightMostEvaluator([])_-1763860698",
      "sourceAnchor": 13,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Collection\u003cEvaluator\u003e])_-549925662",
      "sourceAnchor": 19,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: clear([])_-2025785755",
      "sourceAnchor": 21,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_-1819916956",
      "sourceAnchor": 26,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: ImmediateParent([PsiType:Evaluator])_-2080726655",
      "sourceAnchor": 26,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_1002559824",
      "sourceAnchor": 29,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: Parent([PsiType:Evaluator])_-1690419680",
      "sourceAnchor": 29,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_479247400",
      "sourceAnchor": 32,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: ImmediatePreviousSibling([PsiType:Evaluator])_1112103289",
      "sourceAnchor": 32,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: And([PsiType:Evaluator[]])_146593948",
      "sourceAnchor": 35,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: PreviousSibling([PsiType:Evaluator])_-637666377",
      "sourceAnchor": 35,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: Or([])_403601515",
      "sourceAnchor": 42,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:Evaluator])_1349753049",
      "sourceAnchor": 43,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:Evaluator])_-2094200265",
      "sourceAnchor": 45,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: SelectorParseException([PsiType:String, PsiType:Object[]])_133082493",
      "sourceAnchor": 49,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: replaceRightMostEvaluator([PsiType:Evaluator])_-747212917",
      "sourceAnchor": 53,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: combinator([PsiType:char])_-994109911",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-2096367554",
      "sourceAnchor": 55,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_2082880154",
      "sourceAnchor": 1,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: byId([])_-1584098172",
      "sourceAnchor": 2,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1887198579",
      "sourceAnchor": 3,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: byClass([])_1824868862",
      "sourceAnchor": 4,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchesWord([])_735151700",
      "sourceAnchor": 5,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_709147676",
      "sourceAnchor": 5,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: byTag([])_1950869841",
      "sourceAnchor": 6,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1728850107",
      "sourceAnchor": 7,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: byAttribute([])_-862799262",
      "sourceAnchor": 8,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_1963619738",
      "sourceAnchor": 9,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: allElements([])_-658260729",
      "sourceAnchor": 10,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1576875135",
      "sourceAnchor": 11,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: indexLessThan([])_1639114178",
      "sourceAnchor": 12,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_109202522",
      "sourceAnchor": 13,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: indexGreaterThan([])_269202913",
      "sourceAnchor": 14,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_860516863",
      "sourceAnchor": 15,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: indexEquals([])_103411786",
      "sourceAnchor": 16,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1583237626",
      "sourceAnchor": 17,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: has([])_962310154",
      "sourceAnchor": 18,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_2103060950",
      "sourceAnchor": 19,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: contains([PsiType:boolean])_1869236917",
      "sourceAnchor": 20,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1559035113",
      "sourceAnchor": 21,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: contains([PsiType:boolean])_-234697770",
      "sourceAnchor": 22,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_1200829443",
      "sourceAnchor": 23,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: containsData([])_-1028715522",
      "sourceAnchor": 24,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-482258021",
      "sourceAnchor": 25,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:boolean])_-283984583",
      "sourceAnchor": 26,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_-1205878827",
      "sourceAnchor": 27,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:boolean])_-763490320",
      "sourceAnchor": 28,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matches([PsiType:String])_1453888569",
      "sourceAnchor": 29,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: not([])_-730849667",
      "sourceAnchor": 30,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-433858165",
      "sourceAnchor": 31,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_-1961563394",
      "sourceAnchor": 32,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1162229902",
      "sourceAnchor": 33,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_1854454319",
      "sourceAnchor": 34,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-138666181",
      "sourceAnchor": 35,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_143705935",
      "sourceAnchor": 36,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-68935895",
      "sourceAnchor": 37,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: cssNthChild([PsiType:boolean, PsiType:boolean])_1322254426",
      "sourceAnchor": 38,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1204264972",
      "sourceAnchor": 39,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_638484253",
      "sourceAnchor": 40,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_458730084",
      "sourceAnchor": 41,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-1334764809",
      "sourceAnchor": 42,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_1765706023",
      "sourceAnchor": 43,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_2063697983",
      "sourceAnchor": 44,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: IsFirstOfType([])_-1457611948",
      "sourceAnchor": 44,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_766072227",
      "sourceAnchor": 45,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-446396862",
      "sourceAnchor": 46,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: IsLastOfType([])_-1193966333",
      "sourceAnchor": 46,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_628517266",
      "sourceAnchor": 47,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-701182830",
      "sourceAnchor": 48,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-1298794851",
      "sourceAnchor": 49,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_1205308993",
      "sourceAnchor": 50,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_186799275",
      "sourceAnchor": 51,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_2137167555",
      "sourceAnchor": 52,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_948231577",
      "sourceAnchor": 53,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_1285655212",
      "sourceAnchor": 54,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: matchChomp([PsiType:String])_-402322722",
      "sourceAnchor": 55,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: add([PsiType:E])_-33235083",
      "sourceAnchor": 56,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: SelectorParseException([PsiType:String, PsiType:Object[]])_833794310",
      "sourceAnchor": 58,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: findElements([])_1290835208",
      "target": "MethodSignatureBackedByPsiMethod: remainder([])_-401397909",
      "sourceAnchor": 58,
      "targetAnchor": 0
    },
    {
      "source": "MethodSignatureBackedByPsiMethod: And([PsiType:Collection\u003cEvaluator\u003e])_-1830821654",
      "target": "MethodSignatureBackedByPsiMethod: CombiningEvaluator([PsiType:Collection\u003cEvaluator\u003e])_-907577309",
      "sourceAnchor": 1,
      "targetAnchor": 0
    }
  ]
}